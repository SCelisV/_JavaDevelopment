jdk1.8.0_181

Java Runtime Environment (JRE), está formado por Java Virtual Machine (JVM), clases del núcleo de la plataforma Java y bibliotecas de la plataforma Java de soporte. JRE es la parte de tiempo de ejecución del software de Java, que es todo lo que necesita para ejecutarlo en el explorador web.

¿Qué es el software del plugin de Java?
El software del plugin de Java es un componente de Java Runtime Environment. JRE permite applets escritos en el lenguaje de programación de Java para ejecutar en varios exploradores. El software del plugin de Java no es un programa autónomo y no se puede instalar de forma independiente.

Java Virtual Machine es sólo un aspecto del software de Java que interviene en interacción web. Java Virtual Machine está incorporado en la descarga del software de Java y ayuda a ejecutar las aplicaciones Java.

https://docs.oracle.com/javase/7/docs/technotes/guides/jweb/index.html

http://www.oracle.com/technetwork/java/javase/overview/index.html

http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html#introduction

Instalation: https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html#CJAGAACB

For example, if you were downloading the JDK installer for 32-bit systems for update 1.8.0_01, the file name: jdk-8version-windows-i586.exe becomes jdk-8u1-windows-i586.exe.

------ Esto es viejo... npi 
------ --O-J-O--
PATH
D:\Mis Documentos\Development\Java\JBobadilla;

https://es.atlassian.com/git
everyday.html

Java a través de ejemplos - Jesus Bobadilla - 9788478975495

compile: javac HolaMundo.java
execute: java HolaMundo

_JavaDevelopment/testjdk_1.8.0.292/src/HolaMundo.java

Operadores - Casting 
Tipos de datos primitivos byte, short, int, long, char, float, double y boolean

Operadores - Casting 
_JavaDevelopment/testjdk_1.8.0.292/src/Casting.java

Tipos de datos primitivos byte, short
_JavaDevelopment/testjdk_1.8.0.292/src/TiposEnteros1.java

Tipos de datos primitivos int, long
_JavaDevelopment/testjdk_1.8.0.292/src/TiposEnteros2.java

Tipos de datos primitivos float, double
_JavaDevelopment/testjdk_1.8.0.292/src/TiposDecimales.java

Tipos de datos primitivos boolean
_JavaDevelopment/testjdk_1.8.0.292/src/TipoBooleano.java

Tipos de datos primitivos char
_JavaDevelopment/testjdk_1.8.0.292/src/TipoCaracter.java

Operadores Aritmeticos *, +, -, /, (% int resto ó modulo), ++Variable, Variable++, --Variable, Variable--
_JavaDevelopment/testjdk_1.8.0.292/src/OperadoresAritmeticos.java
Operadores Logicos !, &&, ||
_JavaDevelopment/testjdk_1.8.0.292/src/OperadoresLogicos.java

Operadores de Comparacion <, <=, >, >=, ==, !=
_JavaDevelopment/testjdk_1.8.0.292/src/OperadoresComparacion.java

Estructuras de control: Bucles - For 
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor1.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor2.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor3.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor4.java
_JavaDevelopment/testjdk_1.8.0.292/src/Logistica.java
_JavaDevelopment/testjdk_1.8.0.292/src/Factorial.java

_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor5.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor6a.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor6.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor7.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor8.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor9.java

Estructuras de control: Bucles - While - do While
_JavaDevelopment/testjdk_1.8.0.292/src/BucleWhile3.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleWhile2.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleWhile1.java

Constantes - For anidado
_JavaDevelopment/testjdk_1.8.0.292/src/Primo.java

IF - IF ELSE - ANIDADOS
_JavaDevelopment/testjdk_1.8.0.292/src/IF8.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF7.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF6.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF5.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF4.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF3.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF2.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF1.java
_JavaDevelopment/testjdk_1.8.0.292/src/EcuacionGrado2.java
_JavaDevelopment/testjdk_1.8.0.292/src/PuntodeCorte.java

SWITCH - SWITCH - ANIDADOS
Switch - byte - final - sin break
_JavaDevelopment/testjdk_1.8.0.292/src/Switch9.java
Switch - byte - sin break
_JavaDevelopment/testjdk_1.8.0.292/src/Switch8.java
Switch - byte
_JavaDevelopment/testjdk_1.8.0.292/src/Switch7a.java
_JavaDevelopment/testjdk_1.8.0.292/src/Switch7.java
Switch - int
_JavaDevelopment/testjdk_1.8.0.292/src/Switch1.java
_JavaDevelopment/testjdk_1.8.0.292/src/Switch4.java
Switch - char
_JavaDevelopment/testjdk_1.8.0.292/src/Switch2.java
_JavaDevelopment/testjdk_1.8.0.292/src/Switch3.java
Switch - Anidado - char
_JavaDevelopment/testjdk_1.8.0.292/src/Switch5.java
IF - Anidado - char
_JavaDevelopment/testjdk_1.8.0.292/src/Switch6.java

FOR - MATH - SQRT
Math.sqrt(valor_double) --> esto es porque el método sqrt de la clase Math es estático.
_JavaDevelopment/testjdk_1.8.0.292/src/Hipotenusa.java

Creado el proyecto: testjdk_1.8.0_292

MÉTODOS (Procedimientos, funciones, subrutinas), nos permiten encapsular un conjunto de instrucciones de manera que puedan ser ejecutadas desde diferente puntos de la aplicación. 
Cuando se utiliza un método, se realiza una llamada provocando la ejecución de sus instrucciones y devolviendo, posteriormente, el flujo de control al programa que llama al método.
N todos loa métodos devuelven valores al programa principal, sólo lo hacen si es necesario.

void --> indica que el método no devuelve ningún valor.

Llamadas a un método desde el programa llamante
método()
método(argumentos)

Parámetros: son variables que utiliza el método como valores de partida para sus cálculos. 
su visibilidad y ámbito(existencia), se limitan a los del propio método.
Argumentos: son valores que se establecen en el programa llamante y que se traspasan (por valor o referencia) al método llamado.

Return: debe ser la última del método.
cuando el método no devuelve un valor (void), no es necesario utilizar return, o utilizarla sin un valor asociado.

// Return el valor de la hipotenusa de tipo double - no tiene clausula Return - Es static
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo1.java

// tipo de retorno void, no es necesario utilizar return, o 
// se puede utilizarla sin un valor asociado.
// programa llamante
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo2.java

Paso de argumentos por VALOR y por REFERENCIA
por VALOR
Los argumentos de tipos básicos (primitivos) del lenguaje se pasan a los parámetros POR VALOR, 
esto quiere decir que NO SE TRASPASAN los propios datos, sino una COPIA de los mismos.
tipo byte, short, int, long, char, float, double y boolean
NUNCA se modifican en el programa llamante (aunque sus copias varian en el método llamado)
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo2valor.java

por REFERENCIA - No esta muy claro en el ejemplo - --O-J-O--
Lo que se copia no es el valor del argumento, sino su APUNTADOR(dirección), a la estructura de datos
Es decir, se modifica el valor de la estructura de datos donde apunta el parámetro, 
que es el mismo lugar donde apunta el argumento.
Cuando se realiza un paso de argumentos por referencia, los argumentos varían en la misma medida que varian los parámetros.
Para evitar que los parámetros no puedan modificarse podemos declararlos con final
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo2referencia.java

STRINGS
Los Strings no forman parte de los tipops nativos de Java, sino que existe una clase String(java.lang.String)
Ex: Se declara una estructura de datos basada en el String como parámetros del método main.
Una Instancia de un String es una posición de memoria que apunta hacia una estructura de datos que contiene el conjunto de caracteres que define el String.
un String declarado pero sin definir, NO apunta hacia ninguna estructura de datos, su valor es null.
es diferente a una instancia del objeto String que apunta hacia un conjunto de caracteres vacio.

Dos instancias de un String apuntando hacia contenidos idénticos, no significa que sean iguales.

Para poder comparar dos Strings por su contenido ( y no por su referencia), podemos utilizar el método equals de la clase. 
(compara caracter a caracter.)

Ejemplos del libro
_JavaDevelopment/testjdk_1.8.0.292/src/String1.0.java
_JavaDevelopment/testjdk_1.8.0.292/src/String2.0.java

Otros ejemplos
_JavaDevelopment/testjdk_1.8.0.292/src/String1.java
_JavaDevelopment/testjdk_1.8.0.292/src/String1equals.java

métodos: length(), toUppeCase(), toLowerCase(), substring(), IndexOf
_JavaDevelopment/testjdk_1.8.0.292/src/String2.java

Matrices - Arrays - Vectores
posibilidad para recorrer sus elementos con una instrucción repetitiva

matriz unidimensional de String donde se colocan los posibles parámetros que deseamos pasar al invocar el programa: public static void main (String [] args) 

matriz lineal - int - 2 posiciones - Posicion[0], Posicion[1]
private int[] Posicion = new int[2];

Definición, inicialización, start en 0, Temperaturas
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz.java

Notas, Nombres y Aprobados, se definen listas de diferentes tipos y se recorren con for e imprimen.
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz1.java

Creación de métodos para mejorar la clase Matriz1.java
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz2.java

Creación de una matriz bidimensional de tipo String para almacenar los Alumnos = Nombres + Notas
Se hace uso de los método de la clase Float
parseFloat para convertir de String a float y 
toString para convertir de float a String
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz3.java

--O-J-O-- Revisarlo para que funcione la escritura desde el teclado..  e incluir las mejoras de Matriz3.java
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz3Scanner.java

Do - While - final - Matriz
_JavaDevelopment/testjdk_1.8.0.292/src/GeneraPrimos.java

Do - While Anidados - Clave prefijada -
_JavaDevelopment/testjdk_1.8.0.292/src/RevientaClaves.java
Saber los caracteres del "abcedario"
_JavaDevelopment/testjdk_1.8.0.292/src/RevientaClaves2.java

Utilización de matrices lineales de elementos. - media, variación con respecto de la media, extremos 
_JavaDevelopment/testjdk_1.8.0.292/src/Estadisticas.java

Objetos Class (clases), soportan la programación orientada a objetos, son la estructura básica sobre la que se desarrollan las aplicaciones.

Permite definir propiedades y métodos relacionados entre sí.

Las propiedades variables que almacenan el estado de la clase.
Los métodos son los programas que se utilizan para consultar y modificar el contenido de las propiedades.

Sintaxis de una clase:

AtributoAcceso class NombreClase {
    // propiedades y métodos
}

Un ejemplo de clase podría ser un semáforo de circulación, cuyo estado se guarde en una propiedad 
EstadoSemaforo de tipo String que pueda tomar los valores "Verde", "Amarillo, y "Rojo"
Como métodos de acceso a la propiedad podríamos  definir: PonColor(String Color) y String DimeColor().

------Semaforo.java------------------
|  Propiedad private                 |
|  -------------------------         |
|  | String EstadoSemaforo |         |
|  -------------------------         |                     Métodos public
|                              --------------------------
|                              | PonColor(String Color) | public - me permite acceder al private 
|                              --------------------------          EstadoSemaforo 
|                                    |
|                              -----------------------
|                              | String DimeColor () | public
|                              -----------------------
|                                    |
--------------------------------------

AtributoAcceso:

    // private no es accesible directamente desde el exterior de la clase

    // public son accesibles directamente desde el exterior de la clase

Una Instancia es como crear una plantilla y definir un tipo, se pueden crear tantas entidades (instancias) como sean necesarias...y evolucionar el estado de estas de forma independiente.

Ex: Crear diferentes semáforos independientes entre sí es decir, que cada uno se encuentre en un estado diferente a los demás obligatoriamente SE DEBE instanciar.

    // Para declarar un objeto de una clase dada
    Tipo Variable;

    ex:
    Semaforo MiSemaforo; // De esta manera, creamos un apuntador capaz de direccionar 
                         // un objeto (instancia) de la clase Semaforo.java

    MiSemaforo = new Semaforo(); // Instanciamos 
          |
          V
    Semaforo MiSemaforo = new Semaforo(); // Declaramos e Instanciamos - 
                                          // Tenemos una variable "MiSemaforo", 
                                          // que direcciona un objeto creado de la clase "Semaforo".

    new Semaforo() // Son los constructores de la clase

Se pueden crear tantas instancias como sea necesario, en este caso cada una puede tener un valor diferente en un mismo instante.

// MiSemaforo direcciona un objeto creado (instanciado), de la clase Semaforo:
Semaforo MiSemaforo = new Semaforo();

MiSemaforo
    |
    V
------Semaforo.java------------------
|  Propiedad private                 |
|  -------------------------         |
|  | String EstadoSemaforo |         |
|  -------------------------         |                     Métodos public
|                              --------------------------
|                              | PonColor(String Color) | public - me permite acceder al private 
|                              --------------------------          EstadoSemaforo
|                                    |
|                              -----------------------
|                              | String DimeColor () | public
|                              -----------------------
|                                    |
--------------------------------------

Otras instancias:
Semaforo OtroSemaforo = new Semaforo();
Semaforo SemaforoDeMiCalle = new Semaforo();

Cada instancia es diferente ya que pueden tener un valor diferente en un mismo instante.

Para designar una propiedad o un método de una clase, utilizamos la notación punto:

Objeto.Propiedad
Objeto.Metodo()

Cada variable esta implementando la propiedad EstadoSemaforo.
Cada una de ellas puede contener un valor diferente.

De esta forma, si queremos poner en verde el semaforo "SemaforoDeMiCalle" , empleamos la instrucción:
// Objeto.Metodo()
SemaforoDeMiCalle.PonColor("Verde");
MiSemaforo.PonColor("Rojo");
OtroSemaforo.PonColor("Verde");

Para consulta el estado de un semaforo:

// Objeto.Metodo()
System.out.println(OtroSemaforo.DimeColor());
if(MiSemaforo.DimeColor().equals("Rojo");)
String Luz = SemaforoDeMiCalle.DimeColor();

En nuestro ejemplo NO podemos acceder directamente a la propiedad EstadoSemaforo, por ser privada.
En caso de que fuera pública se podría poner: 
// Objeto.Propiedad
String Luz = SemaforoDeMiCalle.EstadoSemaforo; 

_JavaDevelopment/testjdk_1.8.0.292/src/Semaforo.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSemaforo.java

Sobrecarga de métodos es un mecanismo muy util que permite definir en una clase varios métodos con el mismo nombre y distino número de parámetros.

Para que el compilador pueda determinar a que método nos referimos en un momento dado, los parámetros de los métodos NO PUEDEN SER IDENTICOS.

Ex: Clase para definir un objeto 3D
    Para establecer la dimensión de un objeto (anchura, profundidad, altura) en una medida dada (centimetros,pulgadas, etc), 
    Podemos definir los métodos:

    1. - Dimensiones(double Ancho, double Alto, double Profundo, String Medida)
    2. - Dimensiones(String Medida, double Ancho, double Alto, double Profundo)
    3. - Dimensiones(double Ancho, String Medida, double Alto, double Profundo)
    4. - Dimensiones(double Ancho, double Alto, String Medida, double Profundo)

    Igual número de parámetros, en diferente orden, 
    El compilador podrá determinar a cual de los métodos nos referimos por el la posición de parámetro de tipo String.

    Si definimos el método: El compilador generará un error al compilar la clase

    5. - Dimensiones(double Alto, double Ancho, double Profundo, String Medida)

    El compilador NO podrá determinar a cual de los métodos nos referimos ya que existe un método (1.-) con las mismas condiciones (firma.)
    La firma, se compone del nombre del método, número de parámetros y tipo de parámetros (por orden de colocación). 
    
    métodos sobrecargados con distinto número de parámetros.

    6. - Dimensiones(String Medida)
    7. - Dimensiones(double Ancho, double Alto, double Profundo)

    Los métodos 6 y 7 son compatibles con todos pero tendrían sentido si suponemos dos métodos adicionales que los complementen:

    Dimensiones3D(double Ancho, double Alto, double Profundo)
    TipoMedida(String Medida)

_JavaDevelopment/testjdk_1.8.0.292/src/Objeto3D.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaObjeto3D.java

Constructores son métodos que nos sirven para iniciar los objetos al definirse las instancias de los mismos.
Asignan valores iniciales a las propiedades de la clase, es decir, situar a la clase instanciada en un estado concreto.

La sintaxis de los constructores en la misma que la de los métodos, salvo que no tienen la referencia del atributo de acceso y nunca devuelven ningún valor. (Tampoco se pone la palabra reservada void), además su nombre debe coincidir con el nombre de la clase.

Los constructores suelen estar sobrecargados, para permitir más posibilidades de inicilización de las instancias de las clases.

Los constructores nos permiten, a la vez, crear instancias y establecer el estado inicial de cada objeto instanciado,
a diferencia de lo que hemos realizado en el ejercicio anterior(Objeto3D.java), donde primero debiamos instanciar los objetos y posteriormente, en otras instrucciones, establecer su estado inicial.
(los métodos los convertimos en constructores cambiandoles de nombre y quitandoles los Atributos de Acceso y la palabra "void")

    1. - Objeto3DConConstructor(double Ancho, double Alto, double Profundo, String Medida)
    2. - Objeto3DConConstructor(String Medida, double Ancho, double Alto, double Profundo)
    3. - Objeto3DConConstructor(double Ancho, String Medida, double Alto, double Profundo)
    4. - Objeto3DConConstructor(double Ancho, double Alto, String Medida, double Profundo)
    6. - Objeto3DConConstructor(String Medida)
    7. - Objeto3DConConstructor(double Ancho, double Alto, double Profundo)

    // this invoca a los constructores de esta clase cuya firma coincida con la firma de las instrucciones llamantes

Estos dos métodos complementan a TODOS los DEMÁS métodos sobrecargados "Dimensiones"
    
    Dimensiones3D(double Ancho, double Alto, double Profundo) - permite asignar valores a las tres dimensiones espaciales de un objeto.
    TipoMedida(String Medida) - permite asignar un valor a la propiedad Tipo Medida.

_JavaDevelopment/testjdk_1.8.0.292/src/Objeto3DConConstructor.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaObjeto3DConConstructor.java

_JavaDevelopment/testjdk_1.8.0.292/src/Figura.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaFigura.java

_JavaDevelopment/testjdk_1.8.0.292/src/Telefono.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaTelefono.java

_JavaDevelopment/testjdk_1.8.0.292/src/LogisticaAlmacen.java
_JavaDevelopment/testjdk_1.8.0.292/src/LogisticaControl1Contenedor.java

--O-J-O--
El método setHacerLLamada debe arreglarse para que almacene el String pasado
debería dejarlo con String.. (intentarlo con int..  :/)
_JavaDevelopment/testjdk_1.8.0.292/src/TelefonoSC.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaTelefonoSC.java

CLASES UTILIZADAS COMO PARÁMETROS

Utilizando una clase como parámetros en un método hace posible que el método utilice toda la potencia de los objetos java, independizando las acciones realizadas de los objetos sobre las que las realiza.

Ex: escribir un método llamado ControlIgnicion
ControlIgnicion(Cohete MiVehiculoEspacial){
    realizar operaciones sobre la clase MiVehiculoEspacial de la clase Cohete
}
...
...
El mismo método podria simular el control de ignición de distintos cohetes, siempre que estos estén definidos como instancias de la clase Cohete..
------
| ...
| Cohete Pegasus, Ariane, etc;
| ...
| ...
| ControlIgnicion(Pegasus);
| ControlIgnicion(Ariane);
------
Control Entrada / Salida vehiculos aparcamientos
_JavaDevelopment/testjdk_1.8.0.292/src/Almacen.java
_JavaDevelopment/testjdk_1.8.0.292/src/Puerta.java
_JavaDevelopment/testjdk_1.8.0.292/src/Aparcamiento.java

PROPIEDADES Y METODOS DE CLASE Y DE INSTANCIA

En una clase, las propiedades y los métodos pueden definirse como:

- De instancia
- De clase

Propiedades de instancia: cada vez que se define una instancia de la clase, se crean fisicamente unas nuevas variables que contendrán los valores de dichas propiedades en la instancia creada. Es decir, cada objeto(cada instancia de una clase) contiene sus propios valores en las propiedades de instancia.
Hasta que no se crea una primera instancia de una clase, no existirá ninguna propiedad visible de la clase.

Estructura de la clase (cuando se define).
    |
    V
------Sencilla.java-------------
|                              |
|                        --------------
| PropiedadDeInstancia   |            |
|                        --------------
|                              |
--------------------------------

clase Sencilla{

    public int PropiedadDeInstancia;

}

si ahora intentamos hacer uso de la propiedad PropiedadDeInstancia a través del nombre de la clase:
class PruebaSencilla{
    public static void main(String[] args){
        Sencilla.PropiedadDeInstancia = 8;    // El objeto "Sencilla" no se ha instanciado
    }
}

al compilar javac PruebaSencilla.java
se genera el siguiente error:

PruebaSencilla.java: : error: non-static variable PropiedadDeInstancia cannot be referenced from a static context
        Sencilla.PropiedadDeInstancia = 8;
                ^
1 error

La PropiedadDeInstancia es "NO estática".
Para poder hacer uso de la propiedad se debe crear alguna instanncia de la clase.

class PruebaSencilla2{
    public static void main(String[] args){
        // En este momento existe el objeto y la propiedad
        Sencilla Instancia1 = new Sencilla();

        // Ahora si puedo utilizar la PropiedadDeInstancia de la clase Sencilla.
        Instancia1.PropiedadDeInstancia = 8;
    }
}

Estructura de la clase (instanciada 2 veces por lo que podemos acceder a la PropiedadDeInstancia).
    |
    V
------Sencilla.java-------------
|                              |
|                        --------------
| PropiedadDeInstancia   |            |   <----->
|                        --------------
|                              |
-------------------------------


                            ------Sencilla.java-------------
                            |                              |
           ------------     |                        -------------- 
Instancia1 |          | --> | PropiedadDeInstancia   |            |   <----->
           ------------     |                        --------------
                            |                              |
                            -------------------------------


                            ------Sencilla.java-------------
                            |                              |
           ------------     |                        -------------- 
Instancia2 |          | --> | PropiedadDeInstancia   |            |   <----->
           ------------     |                        --------------
                            |                              |
                            -------------------------------


_JavaDevelopment/testjdk_1.8.0.292/src/Sencilla.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSencilla.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSencilla2.java

Propiedades de clase: (static)
Una propiedad de clase (propiedad estática), se declara con el atributo static
Existe incluso si no se ha creado ninguna instacia de la clase.
Pueden ser referenciadas directamente a través del nombre de la clase sin tener que utilizar el identificador de ninguna instancia

Estructura de la clase con una propiedad de clase static.
    |
    V
--SencillaEstatica.java---------
|                              |
|                              |
|                              |
|------------------------------|
|                        --------------
| PropiedadDeClase       |            | <-->
|                        --------------
|                              |
--------------------------------

class SencillaEstatica{
    public static int PropiedadDeClase;
}

class PruebaSencillaEstatica{
    public static void main (String[] args){
        SencillaEstatica.PropiedadDeClase = 8;
        
    }
}

Las propiedades de clase son compartidas por todas las instancias de la clase.
Al crearse una instancia de la clase, no se crean las variables estáticas de essa clase.
Las variables estáticas (de clase) existen antes de la creación de las instancias de la clase.
Existen aunque no se haya creado el objeto. "new()".

class PruebaSencillaEstatica2{
    public static void main (String[] args){
        SencillaEstatica Instancia1 = new SencillaEstatica();
        SencillaEstatica Instancia2 = new SencillaEstatica();

        // Las siguientes, hacen referencia a la misma variable 
        // (la propiedad estática "PropiedadDeClase" de la clase "SencillaEstatica".).
        SencillaEstatica.PropiedadDeClase = 4;
        Instancia1.PropiedadDeClase = 8;
        Instancia2.PropiedadDeClase = 5;
    }
}

El compilador muestra un Warning:
The static field SencillaEstatica.PropiedadDeClase should be accessed in a static wayJava(570425420)
int PropiedadDeClase
Instancia1.PropiedadDeClase = 8;
Instancia2.PropiedadDeClase = 5;

--SencillaEstatica.java---------
|                              |
|                              |
|                              |
|------------------------------|
|                        --------------                -------------------------------------
| PropiedadDeClase       |            | <------------> | SencillaEstatica.PropiedadDeClase |
|                        --------------                | Instancia1.PropiedadDeClase       |
|                              |                       | Instancia2.PropiedadDeClase       |
|                              |                       -------------------------------------
--------------------------------


                            --SencillaEstatica.java---------
           ------------     |                              |
Instancia1 |          | --> |                              |
           ------------     |                              |
                            --------------------------------

                            --SencillaEstatica.java---------
           ------------     |                              |
Instancia2 |          | --> |                              |
           ------------     |                              |
                            --------------------------------

_JavaDevelopment/testjdk_1.8.0.292/src/SencillaEstatica.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSencillaEstatica.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaSencillaEstatica2.java


En una clase, las propiedades y los métodos pueden definirse como 

De instancia y 
De clase

Los métodos de instancia al igual que las propiedades de instancia, 
sólo pueden ser utilizados a través de una instancia de la clase.
(método main - estático)

-----------
| funcionamiento de los métodos de instancia:
| 
|         LogisticaAlmacen Almacen1 = new LogisticaAlmacen( (byte) 2);
|         LogisticaAlmacen Almacen2 = new LogisticaAlmacen( (byte) 4);
|         LogisticaAlmacen Almacen3 = new LogisticaAlmacen( (byte) 8);
| 
| utilización de los métodos a través del nombre de la instancia
|         if ( Almacen1.hayHueco() )
-----------

Cualquier intento de acceder a un método de instancia a través del nombre de la clase(y no de una instancia de la clase) nos dará error de compilación.

Métodos de clase: (static)

Un método estático puede ser utilizado sin necesidad de definir previamente instancias de la clase que contiene el método. Los métodos estáticos pueden referenciarse a través del nombre de la clase(al igual que las propiedades estáticas). 
Esta posibilidad es útil en diversas circunstancias:

- Cuando el método proporciona una utilidad general.
    No es necesario crear ninguna instancia del método Math.
    Math.sqrt(valor_double) --> esto es porque el método sqrt de la clase Math es estático.

- Cuando el método hace uso de propiedades estáticas u otros métodos estáticos.
    Los métodos estáticos referencian propiedades y métodos estáticos.

No es posible hacer referencia a una propiedad de instancia o un método de instancia desde un método estático. 
Esto es así debido a que en el momento que se ejecuta un método estático puede que no exista ninguna instancia de la clase donde se encuentra la propiedad o el método de instancia al que referencia el método estático.
    |
    |
    V
      ----------                                              ----------
------| Clase1 |----------------                        ------| Clase2 |------------
|     ----------               |                        |     ----------           |
|                              |                        |                          |
|                        --------------                 |--------------------------|
| PropiedadDeInstancia   |            |                 |                    --------------
|                        --------------                 | MetodoEstatico     |            |------------ |                              |                        |                    --------------   |       |
--------------------------------                        |                          |          |       |
                                                        ----------------------------          |       |
                                                                                              |       |
                                              ------------------------------------------------------  |
                                              | Referencias a objetos "potencialmente" inexistente |  |
                                              ------------------------------------------------------  |
                                                                                              |       |
-----------------------------------------------------------------                             |       |
|                                                               |                             |       |
|                        --------->      ----------             |                             |       |
|                        |           ----| Clase1 |-----------  |                             |       |
|                        |           |   ----------          |  |                             |       |
|                   ------------     |                       |  | <----------------------------       |
| Instancia1Clase1  |          |     |  PropiedadDeInstancia |  |                                     |
|                   ------------     |                       |  |                                     |
|                                    -------------------------  |                                     |
|                                                               |                                     |
|                        --------->      ----------             |                                     |
|                        |           ----| Clase1 |-----------  |                                     |
|                        |           |   ----------          |  |                                     |
|                   ------------     |                       |  |                                     |
| Instancia2Clase1  |          | --> |  PropiedadDeInstancia |  | <-----------------------------------
|                   ------------     |                       |  |
|                                    -------------------------  |
|                                                               |
-----------------------------------------------------------------

Los compiladores de Java comprueban estas situaciones y generan errores cuando detectan una referencia a un objeto no estático dentro de un método estático.

// para solucionar el error se deberá definir como:
// static int valor = 8;

class Error{

    int valor = 8;

    public static void main(String[] args) {
        valor = 6;    
    }

}

_JavaDevelopment/testjdk_1.8.0_292/src/Error.java


class NoError{

    static int valor = 8;

    public static void main(String[] args) {
        valor = 6;
    }

}

_JavaDevelopment/testjdk_1.8.0_292/src/NoError.java

Ejemplo con propiedades de clase:

El control de una votación en la que se puede presentar un número cualquiera de candidatos.
En cada momento se puede votar a cualquier candidato y se pueden pedir los siguientes datos:

- Nombre de un candidato concreto y el número de votos que lleva hasta el momento
- Nombre del candidato más votado hasta el momento y número de votos que lleva conseguidos.

La clase Votacion, 
Permite almacenar el nombre de un candidato y el numero de votos que lleva, 
además de los métodos necesarios para actualizar el estado del objeto.
Si instanciamos la clase 14veces por ejemplo... 
se podrá llevar el control de votos de 14 candidatos.

¿Cómo contabilizar el número de votos y almacenar el nombre del candidato más votado hasta el momento?
- Crear una clase "MasVotado", que se instancie una sola vez y 
  contenga propiedades para almacenar estos valores,
  junto a métodos para consultarlos y actualizarlos.

Esta solución NO REQUIERE del uso de una nueva clase "MasVotado" o similar, ni necesita un número fijo de instanciaciones para funcionar. Contiene las propiedades y métodos de acceso a la persona más votada dentro de la propia clase Votacion, en la que se vota a cada persona.

Como el nombre y el número de votos de la persona más votada 
hasta el momento es una información GENERAL.- Sólo existe un espacio de almacenamiento de estas variables.
que NO depende únicamente de los votos de un candidato, 
sino de los votos recibidos por todos los candidatos, 
estas propiedades deben ser accesibles, comunes y compartidas por todos.
Estas variables deben ser estáticas (de clase).

_JavaDevelopment/testjdk_1.8.0_292/src/Votacion.java


             -----------------
-------------| Votacion.java |-----------
|            -----------------          |
|                     --------------    |
| VotosMasVotado      |            |    |                            
|                     --------------    |
|                                       |
|                     --------------    |
| PersonaMasVotada    |            |    |
|                     --------------    |
| Existen desde que se ejecuta la app   |
|                            ----------------------- 
| static                     | VotosDelMasVotado() |
| PROPIEDADES / METODOS      -----------------------
|            DE                         |
|           CLASE            ------------------------ 
|        (Generales)         | NombreDelMasVotado() |
|                            ------------------------ 
|_______________________________________|
|                                       |
|                     --------------    |
|        Votos        |            |    |
|                     --------------    |
|                                       |
|                     --------------    |
|        Persona      |            |    |
|                     --------------    |
|                                       |
|                              ----------------------- 
|                              | NombrePersona()     |
|                              ----------------------- 
| Se replican con cada Instanciación    |
|                                  -----------
|    PROPIEDADES / METODOS         | Voto () |
|               DE                 -----------
|            INSTANCIA                  |
|                                  -----------
|               new()              | Votos() |
|                                  -----------
|_______________________________________|


PAQUETES Y ATRIBUTOS DE ACCESO

Los paquetes sirven para agrupar clases relacionada, de esta manera, cada paquete contiene un conjunto de clases.
Las clases que hay dentro de un paquete deben tener nombres diferentes para que se puedan diferenciar entre sí, peor no hay ningún problema en que dos clases que pertenecen a paquetes diferentes tengan el mismo nombre; los paquetes facilitan tanto el agrupamiento de clases como la asignación de nombres.
Cuando no se especifica el nombre del paquete al que pertenece una clase, esta clase pasa a pertenecer al "paquete por defecto".

Primera sentencia de la clase:  package Nombre_Paquete;  package Terminal;

/home/hadoop/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment/testjdk_1.8.0_292/src/Terminal
total 28K
Ordenador.java
Telefono.java
WebTV.java

Estas clases son accesibles desde fuera de paquete, por ser (public) publicas.

package Terminal;
public class Telefono{
    ...
    ...
}

package Terminal;
public class Ordenador{
    ...
    ...
}

package Terminal;
public class WebTV{
    ...
    ...
}

Cuando necesitamos hacer uso de todas o algunas de las clases de un paquete:
- Especificando la clase que se va a utilizar(junto con la referencia de su paquete);
    import Terminal.Ordenador;
- Se indica que se quiere hacer uso (potencialmente) de todas las clases del paquete.
    import Terminal.*;

SÓLO se pueden usar desde fuera de una paqueta las clases definidas como públicas dentro de ese paquete.

import Terminal.Ordenador;
class TerminalOficinaBancaria{
    // podemos utilizar las referencias deseadas a la clase Ordenador
    // podemos referenciar sus propiedades y métodos de manera directa
}

Estos paquetes de utilidades son tan comunes que no es necesario importarlos para usarlos
java.lang.Math
java.lang.String

Otra alternativa es no utilizar la sentencia import y referenciar los objetos con caminos absolutos:
Esto no es muy legible
Terminal.Telefono MiTelefono = new Terminal.Telefono(...); 
--O-J-O--
Actualizar el CLASSPATH con la ruta en donde almacenamos los paquetes: ejemplo en windows 
C:\Paquetes\Terminal
set CLASSPATH = C:\Paquetes\Terminal en autoexec.bat
ó 
CLASSPATH = C:\Paquetes\Terminal

javac --classpath C:\Paquetes\Terminal\TerminalOficinaBancaria.java

_JavaDevelopment/testjdk_1.8.0_292/src/TerminalOficinaBancaria.java

--O-J-O--
atributos de acceso (public) y (private) indican acceso a las propiedades y métodos de una clase desde el exterior a la misma.
Los atributos son de acceso (private) y sólo se puede acceder a ellos (en consulta o modificación) a través de métodos públicos.

----------------------------------------------------------------------------------------
|                |                   |                         | Acceso    | Acceso    |
|                |                   |                         |   desde   |  desde    |
| Tipo de acceso | Palabra reservada | Ejemplo                 | una clase | una clase |
|                |                   |                         | del MISMO | de OTRO   |
|                |                   |                         | PAQUETE   | PAQUETE   |
----------------------------------------------------------------------------------------
|  Privado       |    private        | private int Propiedad   |    NO     |     NO    |
----------------------------------------------------------------------------------------
|Sin Especificar |                   |         int Propiedad   |    SI     |     NO    | ----------------------------------------------------------------------------------------
|  Protegido     |    protected      | protected int Propiedad |    SI     |     NO    | ----------------------------------------------------------------------------------------
|  Público       |    public         | public int Propiedad    |    SI     |     SI    |
----------------------------------------------------------------------------------------

El acceso desde una clase perteneciente al MISMO PAQUETE sólo esta prohibido si el miembro es privado.
El acceso desde una clase perteneciente a OTRO PAQUETE sólo está permitido si el miembro es público:

Ex
package ConversionDeMedidas;
public class ConversionDeDistancias{
    // puede ser referenciada desde un paquete/clase (VentaDeProductos/VentaDeNaranjas)
    // por ser definida como public
    final public double LibrasAKilos = ... ;
}

package VentaDeProductos;
import ConversionDeMedidas.ConversionDeDistancias;
class VentaDeNaranjas{
    ...
    double Kilos = Libras * LibrasAKilos;
}

Los otros atributos tienen sentido en herencia.

MAQUINA EXPENDEDORA
Controlar el funcionamiento de una máquina expendedora sencilla.
Suministra botellas de agua, naranja y coca-cola
Establecer los precios de cada producto
Admite monedas de 1€, y de 10centimos(0.1€).
Definir una máquina con cualquier numero de productos
- Cuantas botellas de agua nos quedan (en el deposito de botellas de agua)
- Cuantas botellas de naranja nos quedan (en el deposito de botellas de naranja)
- Cuantas botellas de coca-cola nos quedan (en el deposito de botellas de coca-cola)
- Cuantas monedas de Euro nos quedan (en el deposito de monedas de Euro)
- Cuantas monedas de 10centimos de Euro nos quedan (en el deposito de monedas de 10centimos de Euro)
Esta clase gestionará un Almacén de elementos reutilizar Almacen.java en MaquinaAlmacen.java

    /*---------------------
    // Propiedades de Instancia
    // Esta forma es más adaptada a la programación orientada a objetos
    // Definidas como private e incorporar los métodos para 
    // obtener sus referencias
    // Algo como: --- pendiente de probar
    private MaquinaAlmacen DepositoAgua = new MaquinaAlmacen((short) 8);

    public MaquinaModeloSencillo getAlmacenAgua(){
    ó 
    public MaquinaModeloSencillo getAlmacen(String TipoAlmacen)
    */


Se podría crear nuevas clases que definieran más productos ó mejor aún
Ampliar esta clase con nuevos productos. --> ver Herencia

Las máquinas definidas o las que podamos crear siguiendo el patron de MaquinaModeloSencillo necesitan un elemento adicional, el control de las monedas.

_JavaDevelopment/testjdk_1.8.0_292/src/MaquinaAlmacen.java
_JavaDevelopment/testjdk_1.8.0_292/src/MaquinaModeloSencillo.java
_JavaDevelopment/testjdk_1.8.0_292/src/MaquinaAutomataEuros.java



// ????
// Las que no, sólo son accesibles desde dentro del paquete(sirven para dar soporte a las clases públicas)
// ????

        if( Impuesto instanceof float) {
            System.out.println("Impuesto is a float");
        }
        else if( Impuesto instanceof Integer) {
            System.out.println("Impuesto is an Integer");
        }

        if( Impuesto instanceof Comparable) {
            //subclasses of Number like Double etc. implement Comparable
            //other subclasses might not -> you could pass Number instances that don't implement that interface
            System.out.println("Impuesto is comparable"); 
        }
