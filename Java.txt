jdk1.8.0_181

https://docs.oracle.com/javase/8/docs/

Java Runtime Environment (JRE), está formado por Java Virtual Machine (JVM), clases del núcleo de la plataforma Java y bibliotecas de la plataforma Java de soporte. JRE es la parte de tiempo de ejecución del software de Java, que es todo lo que necesita para ejecutarlo en el explorador web.

¿Qué es el software del plugin de Java?
El software del plugin de Java es un componente de Java Runtime Environment. JRE permite applets escritos en el lenguaje de programación de Java para ejecutar en varios exploradores. El software del plugin de Java no es un programa autónomo y no se puede instalar de forma independiente.

Java Virtual Machine es sólo un aspecto del software de Java que interviene en interacción web. Java Virtual Machine está incorporado en la descarga del software de Java y ayuda a ejecutar las aplicaciones Java.

https://docs.oracle.com/javase/7/docs/technotes/guides/jweb/index.html

http://www.oracle.com/technetwork/java/javase/overview/index.html

http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html#introduction

Instalation: https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html#CJAGAACB

For example, if you were downloading the JDK installer for 32-bit systems for update 1.8.0_01, the file name: jdk-8version-windows-i586.exe becomes jdk-8u1-windows-i586.exe.

------ Esto es viejo... npi 
------ --O-J-O--
PATH
D:\Mis Documentos\Development\Java\JBobadilla;
which java
java -version

grep -n -- 'something' *.java
find -name '*Listener'*.Java
find -name 'Listener?'*.java

execute
cd /home/hadoop/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment/testjdk_1.8.0_292/src ; /usr/bin/env /usr/lib/jvm/java-11-openjdk-amd64/bin/java -Dfile.encoding=UTF-8 -cp /home/hadoop/.config/Code/User/workspaceStorage/25fa5dc2bf9cb43a259787a70c062b18/redhat.java/jdt_ws/src_5bfeb882/bin Calculadora1

objects..??
ls /home/hadoop/.config/Code/User/workspaceStorage/25fa5dc2bf9cb43a259787a70c062b18/redhat.java/jdt_ws/src_5bfeb882/bin/
??
/home/hadoop/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment/testjdk_1.8.0_292/src

https://es.atlassian.com/git

https://jarroba.com/annotations-anotaciones-en-java/

everyday.html

Java a través de ejemplos - Jesus Bobadilla - ISBN: 9788478975495

compile: javac HolaMundo.java
execute: java HolaMundo

_JavaDevelopment/testjdk_1.8.0.292/src/HolaMundo.java

Operadores - Casting 
Tipos de datos primitivos byte, short, int, long, char, float, double y boolean

Operadores - Casting 
_JavaDevelopment/testjdk_1.8.0.292/src/Casting.java

Tipos de datos primitivos byte, short
_JavaDevelopment/testjdk_1.8.0.292/src/TiposEnteros1.java

Tipos de datos primitivos int, long
_JavaDevelopment/testjdk_1.8.0.292/src/TiposEnteros2.java

Tipos de datos primitivos float, double
_JavaDevelopment/testjdk_1.8.0.292/src/TiposDecimales.java

Tipos de datos primitivos boolean
_JavaDevelopment/testjdk_1.8.0.292/src/TipoBooleano.java

Tipos de datos primitivos char
_JavaDevelopment/testjdk_1.8.0.292/src/TipoCaracter.java

Operadores Aritmeticos *, +, -, /, (% int resto ó modulo), ++Variable, Variable++, --Variable, Variable--
_JavaDevelopment/testjdk_1.8.0.292/src/OperadoresAritmeticos.java
Operadores Logicos !, &&, ||
_JavaDevelopment/testjdk_1.8.0.292/src/OperadoresLogicos.java

Operadores de Comparacion <, <=, >, >=, ==, !=
_JavaDevelopment/testjdk_1.8.0.292/src/OperadoresComparacion.java

Estructuras de control: Bucles - For 
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor1.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor2.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor3.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor4.java
_JavaDevelopment/testjdk_1.8.0.292/src/Logistica.java
_JavaDevelopment/testjdk_1.8.0.292/src/Factorial.java

_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor5.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor6a.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor6.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor7.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor8.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor9.java

Estructuras de control: Bucles - While - do While
_JavaDevelopment/testjdk_1.8.0.292/src/BucleWhile3.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleWhile2.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleWhile1.java

Constantes - For anidado
_JavaDevelopment/testjdk_1.8.0.292/src/Primo.java

IF - IF ELSE - ANIDADOS
_JavaDevelopment/testjdk_1.8.0.292/src/IF8.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF7.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF6.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF5.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF4.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF3.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF2.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF1.java
_JavaDevelopment/testjdk_1.8.0.292/src/EcuacionGrado2.java
_JavaDevelopment/testjdk_1.8.0.292/src/PuntodeCorte.java

SWITCH - SWITCH - ANIDADOS
Switch - byte - final - sin break
_JavaDevelopment/testjdk_1.8.0.292/src/Switch9.java
Switch - byte - sin break
_JavaDevelopment/testjdk_1.8.0.292/src/Switch8.java
Switch - byte
_JavaDevelopment/testjdk_1.8.0.292/src/Switch7a.java
_JavaDevelopment/testjdk_1.8.0.292/src/Switch7.java
Switch - int
_JavaDevelopment/testjdk_1.8.0.292/src/Switch1.java
_JavaDevelopment/testjdk_1.8.0.292/src/Switch4.java
Switch - char
_JavaDevelopment/testjdk_1.8.0.292/src/Switch2.java
_JavaDevelopment/testjdk_1.8.0.292/src/Switch3.java
Switch - Anidado - char
_JavaDevelopment/testjdk_1.8.0.292/src/Switch5.java
IF - Anidado - char
_JavaDevelopment/testjdk_1.8.0.292/src/Switch6.java

FOR - MATH - SQRT
Math.sqrt(valor_double) --> esto es porque el método sqrt de la clase Math es estático.
_JavaDevelopment/testjdk_1.8.0.292/src/Hipotenusa.java

Creado el proyecto: testjdk_1.8.0_292

MÉTODOS (Procedimientos, funciones, subrutinas), nos permiten encapsular un conjunto de instrucciones de manera que puedan ser ejecutadas desde diferente puntos de la aplicación. 
Cuando se utiliza un método, se realiza una llamada provocando la ejecución de sus instrucciones y devolviendo, posteriormente, el flujo de control al programa que llama al método.
N todos loa métodos devuelven valores al programa principal, sólo lo hacen si es necesario.

void --> indica que el método no devuelve ningún valor.

Llamadas a un método desde el programa llamante
método()
método(argumentos)

Parámetros: son variables que utiliza el método como valores de partida para sus cálculos. 
su visibilidad y ámbito(existencia), se limitan a los del propio método.
Argumentos: son valores que se establecen en el programa llamante y que se traspasan (por valor o referencia) al método llamado.

Return: debe ser la última del método.
cuando el método no devuelve un valor (void), no es necesario utilizar return, o utilizarla sin un valor asociado.

// Return el valor de la hipotenusa de tipo double - no tiene clausula Return - Es static
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo1.java

// tipo de retorno void, no es necesario utilizar return, o 
// se puede utilizarla sin un valor asociado.
// programa llamante
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo2.java

Paso de argumentos por VALOR y por REFERENCIA
por VALOR
Los argumentos de tipos básicos (primitivos) del lenguaje se pasan a los parámetros POR VALOR, 
esto quiere decir que NO SE TRASPASAN los propios datos, sino una COPIA de los mismos.
tipo byte, short, int, long, char, float, double y boolean
NUNCA se modifican en el programa llamante (aunque sus copias varian en el método llamado)
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo2valor.java

por REFERENCIA - No esta muy claro en el ejemplo - --O-J-O--
Lo que se copia no es el valor del argumento, sino su APUNTADOR(dirección), a la estructura de datos
Es decir, se modifica el valor de la estructura de datos donde apunta el parámetro, 
que es el mismo lugar donde apunta el argumento.
Cuando se realiza un paso de argumentos por referencia, los argumentos varían en la misma medida que varian los parámetros.
Para evitar que los parámetros no puedan modificarse podemos declararlos con final
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo2referencia.java

STRINGS
Los Strings no forman parte de los tipops nativos de Java, sino que existe una clase String(java.lang.String)
Ex: Se declara una estructura de datos basada en el String como parámetros del método main.
Una Instancia de un String es una posición de memoria que apunta hacia una estructura de datos que contiene el conjunto de caracteres que define el String.
un String declarado pero sin definir, NO apunta hacia ninguna estructura de datos, su valor es null.
es diferente a una instancia del objeto String que apunta hacia un conjunto de caracteres vacio.

Dos instancias de un String apuntando hacia contenidos idénticos, no significa que sean iguales.

Para poder comparar dos Strings por su contenido ( y no por su referencia), podemos utilizar el método equals de la clase. 
(compara caracter a caracter.)

Ejemplos del libro
_JavaDevelopment/testjdk_1.8.0.292/src/String1_0.java
_JavaDevelopment/testjdk_1.8.0.292/src/String2_0.java

Otros ejemplos
_JavaDevelopment/testjdk_1.8.0.292/src/String1.java
_JavaDevelopment/testjdk_1.8.0.292/src/String1equals.java

métodos: length(), toUppeCase(), toLowerCase(), substring(), IndexOf
_JavaDevelopment/testjdk_1.8.0.292/src/String2.java

Matrices - Arrays - Vectores
posibilidad para recorrer sus elementos con una instrucción repetitiva

matriz unidimensional de String donde se colocan los posibles parámetros que deseamos pasar al invocar el programa: public static void main (String [] args) 

matriz lineal - int - 2 posiciones - Posicion[0], Posicion[1]
private int[] Posicion = new int[2];

Definición, inicialización, start en 0, Temperaturas
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz.java

Notas, Nombres y Aprobados, se definen listas de diferentes tipos y se recorren con for e imprimen.
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz1.java

Creación de métodos para mejorar la clase Matriz1.java
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz2.java

Creación de una matriz bidimensional de tipo String para almacenar los Alumnos = Nombres + Notas
Se hace uso de los método de la clase Float
parseFloat para convertir de String a float y 
toString para convertir de float a String
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz3.java

--O-J-O-- Revisarlo para que funcione la escritura desde el teclado..  e incluir las mejoras de Matriz3.java
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz3Scanner.java

Do - While - final - Matriz
_JavaDevelopment/testjdk_1.8.0.292/src/GeneraPrimos.java

Do - While Anidados - Clave prefijada -
_JavaDevelopment/testjdk_1.8.0.292/src/RevientaClaves.java
Saber los caracteres del "abcedario"
_JavaDevelopment/testjdk_1.8.0.292/src/RevientaClaves2.java

Utilización de matrices lineales de elementos. - media, variación con respecto de la media, extremos 
_JavaDevelopment/testjdk_1.8.0.292/src/Estadisticas.java

Objetos Class (clases), soportan la programación orientada a objetos, son la estructura básica sobre la que se desarrollan las aplicaciones.

Permite definir propiedades y métodos relacionados entre sí.

Las propiedades variables que almacenan el estado de la clase.
Los métodos son los programas que se utilizan para consultar y modificar el contenido de las propiedades.

Sintaxis de una clase:

AtributoAcceso class NombreClase {
    // propiedades y métodos
}

Un ejemplo de clase podría ser un semáforo de circulación, cuyo estado se guarde en una propiedad 
EstadoSemaforo de tipo String que pueda tomar los valores "Verde", "Amarillo, y "Rojo"
Como métodos de acceso a la propiedad podríamos  definir: PonColor(String Color) y String DimeColor().

------Semaforo.java------------------
|  Propiedad private                 |
|  -------------------------         |
|  | String EstadoSemaforo |         |
|  -------------------------         |                     Métodos public
|                              --------------------------
|                              | PonColor(String Color) | public - me permite acceder al private 
|                              --------------------------          EstadoSemaforo 
|                                    |
|                              -----------------------
|                              | String DimeColor () | public
|                              -----------------------
|                                    |
--------------------------------------

AtributoAcceso:

    // private no es accesible directamente desde el exterior de la clase

    // public son accesibles directamente desde el exterior de la clase

Una Instancia es como crear una plantilla y definir un tipo, se pueden crear tantas entidades (instancias) como sean necesarias...y evolucionar el estado de estas de forma independiente.

Ex: Crear diferentes semáforos independientes entre sí es decir, que cada uno se encuentre en un estado diferente a los demás obligatoriamente SE DEBE instanciar.

    // Para declarar un objeto de una clase dada
    Tipo Variable;

    ex:
    Semaforo MiSemaforo; // De esta manera, creamos un apuntador capaz de direccionar 
                         // un objeto (instancia) de la clase Semaforo.java

    MiSemaforo = new Semaforo(); // Instanciamos 
          |
          V
    Semaforo MiSemaforo = new Semaforo(); // Declaramos e Instanciamos - 
                                          // Tenemos una variable "MiSemaforo", 
                                          // que direcciona un objeto creado de la clase "Semaforo".

    new Semaforo() // Son los constructores de la clase

Se pueden crear tantas instancias como sea necesario, en este caso cada una puede tener un valor diferente en un mismo instante.

// MiSemaforo direcciona un objeto creado (instanciado), de la clase Semaforo:
Semaforo MiSemaforo = new Semaforo();

MiSemaforo
    |
    V
------Semaforo.java------------------
|  Propiedad private                 |
|  -------------------------         |
|  | String EstadoSemaforo |         |
|  -------------------------         |                     Métodos public
|                              --------------------------
|                              | PonColor(String Color) | public - me permite acceder al private 
|                              --------------------------          EstadoSemaforo
|                                    |
|                              -----------------------
|                              | String DimeColor () | public
|                              -----------------------
|                                    |
--------------------------------------

Otras instancias:
Semaforo OtroSemaforo = new Semaforo();
Semaforo SemaforoDeMiCalle = new Semaforo();

Cada instancia es diferente ya que pueden tener un valor diferente en un mismo instante.

Para designar una propiedad o un método de una clase, utilizamos la notación punto:

Objeto.Propiedad
Objeto.Metodo()

Cada variable esta implementando la propiedad EstadoSemaforo.
Cada una de ellas puede contener un valor diferente.

De esta forma, si queremos poner en verde el semaforo "SemaforoDeMiCalle" , empleamos la instrucción:
// Objeto.Metodo()
SemaforoDeMiCalle.PonColor("Verde");
MiSemaforo.PonColor("Rojo");
OtroSemaforo.PonColor("Verde");

Para consulta el estado de un semaforo:

// Objeto.Metodo()
System.out.println(OtroSemaforo.DimeColor());
if(MiSemaforo.DimeColor().equals("Rojo");)
String Luz = SemaforoDeMiCalle.DimeColor();

En nuestro ejemplo NO podemos acceder directamente a la propiedad EstadoSemaforo, por ser privada.
En caso de que fuera pública se podría poner: 
// Objeto.Propiedad
String Luz = SemaforoDeMiCalle.EstadoSemaforo; 

_JavaDevelopment/testjdk_1.8.0.292/src/Semaforo.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSemaforo.java

Sobrecarga de métodos es un mecanismo muy util que permite definir en una clase varios métodos con el mismo nombre y distino número de parámetros.

Para que el compilador pueda determinar a que método nos referimos en un momento dado, los parámetros de los métodos NO PUEDEN SER IDENTICOS.

Ex: Clase para definir un objeto 3D
    Para establecer la dimensión de un objeto (anchura, profundidad, altura) en una medida dada (centimetros,pulgadas, etc), 
    Podemos definir los métodos:

    1. - Dimensiones(double Ancho, double Alto, double Profundo, String Medida)
    2. - Dimensiones(String Medida, double Ancho, double Alto, double Profundo)
    3. - Dimensiones(double Ancho, String Medida, double Alto, double Profundo)
    4. - Dimensiones(double Ancho, double Alto, String Medida, double Profundo)

    Igual número de parámetros, en diferente orden, 
    El compilador podrá determinar a cual de los métodos nos referimos por la posición de parámetro de tipo String.

    Si definimos el método: El compilador generará un error al compilar la clase

    5. - Dimensiones(double Alto, double Ancho, double Profundo, String Medida)

    El compilador NO podrá determinar a cual de los métodos nos referimos ya que existe un método (1.-) con las mismas condiciones (firma.)
    La firma, se compone del nombre del método, número de parámetros y tipo de parámetros (por orden de colocación). 
    
    métodos sobrecargados con distinto número de parámetros.

    6. - Dimensiones(String Medida)
    7. - Dimensiones(double Ancho, double Alto, double Profundo)

    Los métodos 6 y 7 son compatibles con todos pero tendrían sentido si suponemos dos métodos adicionales que los complementen:

    Dimensiones3D(double Ancho, double Alto, double Profundo)
    TipoMedida(String Medida)

_JavaDevelopment/testjdk_1.8.0.292/src/Objeto3D.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaObjeto3D.java

Constructores son métodos que nos sirven para iniciar los objetos al definirse las instancias de los mismos.
Asignan valores iniciales a las propiedades de la clase, es decir, situar a la clase instanciada en un estado concreto.

La sintaxis de los constructores en la misma que la de los métodos, salvo que no tienen la referencia del atributo de acceso y nunca devuelven ningún valor. (Tampoco se pone la palabra reservada void), además su nombre debe coincidir con el nombre de la clase.

Los constructores suelen estar sobrecargados, para permitir más posibilidades de inicilización de las instancias de las clases.

Los constructores nos permiten, a la vez, crear instancias y establecer el estado inicial de cada objeto instanciado,
a diferencia de lo que hemos realizado en el ejercicio anterior(Objeto3D.java), donde primero debiamos instanciar los objetos y posteriormente, en otras instrucciones, establecer su estado inicial.
(los métodos los convertimos en constructores cambiandoles de nombre y quitandoles los Atributos de Acceso y la palabra "void")

    1. - Objeto3DConConstructor(double Ancho, double Alto, double Profundo, String Medida)
    2. - Objeto3DConConstructor(String Medida, double Ancho, double Alto, double Profundo)
    3. - Objeto3DConConstructor(double Ancho, String Medida, double Alto, double Profundo)
    4. - Objeto3DConConstructor(double Ancho, double Alto, String Medida, double Profundo)
    6. - Objeto3DConConstructor(String Medida)
    7. - Objeto3DConConstructor(double Ancho, double Alto, double Profundo)

    // this invoca a los constructores de esta clase cuya firma coincida con la firma de las instrucciones llamantes

Estos dos métodos complementan a TODOS los DEMÁS métodos sobrecargados "Dimensiones"
    
    Dimensiones3D(double Ancho, double Alto, double Profundo) - permite asignar valores a las tres dimensiones espaciales de un objeto.
    TipoMedida(String Medida) - permite asignar un valor a la propiedad Tipo Medida.

_JavaDevelopment/testjdk_1.8.0.292/src/Objeto3DConConstructor.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaObjeto3DConConstructor.java

    // this se refiere a la clase Figura, no a la variable Posicion

_JavaDevelopment/testjdk_1.8.0.292/src/Figura.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaFigura.java

    // se rellena la matriz en forma de buffer circular (se consigue con %), 

_JavaDevelopment/testjdk_1.8.0.292/src/Telefono.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaTelefono.java

_JavaDevelopment/testjdk_1.8.0.292/src/LogisticaAlmacen.java
_JavaDevelopment/testjdk_1.8.0.292/src/LogisticaControl1Contenedor.java

--O-J-O--
El método setHacerLLamada debe arreglarse para que almacene el String pasado
debería dejarlo con String.. (intentarlo con int..  :/)
_JavaDevelopment/testjdk_1.8.0.292/src/TelefonoSC.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaTelefonoSC.java

CLASES UTILIZADAS COMO PARÁMETROS

Utilizando una clase como parámetros en un método hace posible que el método utilice toda la potencia de los objetos java, independizando las acciones realizadas de los objetos sobre las que las realiza.

Ex: escribir un método llamado ControlIgnicion
ControlIgnicion(Cohete MiVehiculoEspacial){
    realizar operaciones sobre la clase MiVehiculoEspacial de la clase Cohete
}
...
...
El mismo método podria simular el control de ignición de distintos cohetes, siempre que estos estén definidos como instancias de la clase Cohete..
------
| ...
| Cohete Pegasus, Ariane, etc;
| ...
| ...
| ControlIgnicion(Pegasus);
| ControlIgnicion(Ariane);
------
Control Entrada / Salida vehiculos aparcamientos
_JavaDevelopment/testjdk_1.8.0.292/src/Almacen.java
_JavaDevelopment/testjdk_1.8.0.292/src/Puerta.java
_JavaDevelopment/testjdk_1.8.0.292/src/Aparcamiento.java

PROPIEDADES Y METODOS DE CLASE Y DE INSTANCIA

En una clase, las propiedades y los métodos pueden definirse como:

- De instancia
- De clase

Propiedades de instancia: cada vez que se define una instancia de la clase, se crean fisicamente unas nuevas variables que contendrán los valores de dichas propiedades en la instancia creada. Es decir, cada objeto(cada instancia de una clase) contiene sus propios valores en las propiedades de instancia.
Hasta que no se crea una primera instancia de una clase, no existirá ninguna propiedad visible de la clase.

Estructura de la clase (cuando se define).
    |
    V
------Sencilla.java-------------
|                              |
|                        --------------
| PropiedadDeInstancia   |            |
|                        --------------
|                              |
--------------------------------

clase Sencilla{

    public int PropiedadDeInstancia;

}

si ahora intentamos hacer uso de la propiedad PropiedadDeInstancia a través del nombre de la clase:
class PruebaSencilla{
    public static void main(String[] args){
        Sencilla.PropiedadDeInstancia = 8;    // El objeto "Sencilla" no se ha instanciado
    }
}

al compilar javac PruebaSencilla.java
se genera el siguiente error:

PruebaSencilla.java: : error: non-static variable PropiedadDeInstancia cannot be referenced from a static context
        Sencilla.PropiedadDeInstancia = 8;
                ^
1 error

La PropiedadDeInstancia es "NO estática".
Para poder hacer uso de la propiedad se debe crear alguna instanncia de la clase.

class PruebaSencilla2{
    public static void main(String[] args){
        // En este momento existe el objeto y la propiedad
        Sencilla Instancia1 = new Sencilla();

        // Ahora si puedo utilizar la PropiedadDeInstancia de la clase Sencilla.
        Instancia1.PropiedadDeInstancia = 8;
    }
}

Estructura de la clase (instanciada 2 veces por lo que podemos acceder a la PropiedadDeInstancia).
    |
    V
------Sencilla.java-------------
|                              |
|                        --------------
| PropiedadDeInstancia   |            |   <----->
|                        --------------
|                              |
-------------------------------


                            ------Sencilla.java-------------
                            |                              |
           ------------     |                        -------------- 
Instancia1 |          | --> | PropiedadDeInstancia   |            |   <----->
           ------------     |                        --------------
                            |                              |
                            -------------------------------


                            ------Sencilla.java-------------
                            |                              |
           ------------     |                        -------------- 
Instancia2 |          | --> | PropiedadDeInstancia   |            |   <----->
           ------------     |                        --------------
                            |                              |
                            -------------------------------


_JavaDevelopment/testjdk_1.8.0.292/src/Sencilla.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSencilla.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSencilla2.java

Propiedades de clase: (static) - ver ejemplo en _JavaDevelopment/testjdk_1.8.0_292/src/ProcesaEvento.java

Una propiedad de clase (propiedad estática), se declara con el atributo static
Existe incluso si no se ha creado ninguna instacia de la clase.
Pueden ser referenciadas directamente a través del nombre de la clase sin tener que utilizar el identificador de ninguna instancia

Estructura de la clase con una propiedad de clase static.
    |
    V
--SencillaEstatica.java---------
|                              |
|                              |
|                              |
|------------------------------|
|                        --------------
| PropiedadDeClase       |            | <-->
|                        --------------
|                              |
--------------------------------

class SencillaEstatica{
    public static int PropiedadDeClase;
}

class PruebaSencillaEstatica{
    public static void main (String[] args){
        SencillaEstatica.PropiedadDeClase = 8;
        
    }
}

Las propiedades de clase son compartidas por todas las instancias de la clase.
Al crearse una instancia de la clase, no se crean las variables estáticas de essa clase.
Las variables estáticas (de clase) existen antes de la creación de las instancias de la clase.
Existen aunque no se haya creado el objeto. "new()".

class PruebaSencillaEstatica2{
    public static void main (String[] args){
        SencillaEstatica Instancia1 = new SencillaEstatica();
        SencillaEstatica Instancia2 = new SencillaEstatica();

        // Las siguientes, hacen referencia a la misma variable 
        // (la propiedad estática "PropiedadDeClase" de la clase "SencillaEstatica".).
        SencillaEstatica.PropiedadDeClase = 4;
        Instancia1.PropiedadDeClase = 8;
        Instancia2.PropiedadDeClase = 5;
    }
}

El compilador muestra un Warning:
The static field SencillaEstatica.PropiedadDeClase should be accessed in a static wayJava(570425420)
int PropiedadDeClase
Instancia1.PropiedadDeClase = 8;
Instancia2.PropiedadDeClase = 5;

--SencillaEstatica.java---------
|                              |
|                              |
|                              |
|------------------------------|
|                        --------------                -------------------------------------
| PropiedadDeClase       |            | <------------> | SencillaEstatica.PropiedadDeClase |
|                        --------------                | Instancia1.PropiedadDeClase       |
|                              |                       | Instancia2.PropiedadDeClase       |
|                              |                       -------------------------------------
--------------------------------


                            --SencillaEstatica.java---------
           ------------     |                              |
Instancia1 |          | --> |                              |
           ------------     |                              |
                            --------------------------------

                            --SencillaEstatica.java---------
           ------------     |                              |
Instancia2 |          | --> |                              |
           ------------     |                              |
                            --------------------------------

_JavaDevelopment/testjdk_1.8.0.292/src/SencillaEstatica.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSencillaEstatica.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaSencillaEstatica2.java


En una clase, las propiedades y los métodos pueden definirse como 

De instancia y 
De clase

Los métodos de instancia al igual que las propiedades de instancia, 
sólo pueden ser utilizados a través de una instancia de la clase.
(método main - estático)

-----------
| funcionamiento de los métodos de instancia:
| 
|         LogisticaAlmacen Almacen1 = new LogisticaAlmacen( (byte) 2);
|         LogisticaAlmacen Almacen2 = new LogisticaAlmacen( (byte) 4);
|         LogisticaAlmacen Almacen3 = new LogisticaAlmacen( (byte) 8);
| 
| utilización de los métodos a través del nombre de la instancia
|         if ( Almacen1.hayHueco() )
-----------

Cualquier intento de acceder a un método de instancia a través del nombre de la clase(y no de una instancia de la clase) nos dará error de compilación.

Métodos de clase: (static) -> ver otro ejemplo en _JavaDevelopment/testjdk_1.8.0_292/src/ProcesaEvento.java 

Un método estático puede ser utilizado sin necesidad de definir previamente instancias de la clase que contiene el método. Los métodos estáticos pueden referenciarse a través del nombre de la clase(al igual que las propiedades estáticas). 
Esta posibilidad es útil en diversas circunstancias:

- Cuando el método proporciona una utilidad general.
    No es necesario crear ninguna instancia del método Math.
    Math.sqrt(valor_double) --> esto es porque el método sqrt de la clase Math es estático.

- Cuando el método hace uso de propiedades estáticas u otros métodos estáticos.
    Los métodos estáticos referencian propiedades y métodos estáticos.

No es posible hacer referencia a una propiedad de instancia o un método de instancia desde un método estático. 
Esto es así debido a que en el momento que se ejecuta un método estático puede que no exista ninguna instancia de la clase donde se encuentra la propiedad o el método de instancia al que referencia el método estático.
    |
    |
    V
      ----------                                              ----------
------| Clase1 |----------------                        ------| Clase2 |------------
|     ----------               |                        |     ----------           |
|                              |                        |                          |
|                        --------------                 |--------------------------|
| PropiedadDeInstancia   |            |                 |                    --------------
|                        --------------                 | MetodoEstatico     |            |------------
|                               |                       |                    --------------
--------------------------------                        |                          |          |       |
                                                        ----------------------------          |       |
                                                                                              |       |
                                              ------------------------------------------------------  |
                                              | Referencias a objetos "potencialmente" inexistente |  |
                                              ------------------------------------------------------  |
                                                                                              |       |
-----------------------------------------------------------------                             |       |
|                                                               |                             |       |
|                        --------->      ----------             |                             |       |
|                        |           ----| Clase1 |-----------  |                             |       |
|                        |           |   ----------          |  |                             |       |
|                   ------------     |                       |  | <----------------------------       |
| Instancia1Clase1  |          |     |  PropiedadDeInstancia |  |                                     |
|                   ------------     |                       |  |                                     |
|                                    -------------------------  |                                     |
|                                                               |                                     |
|                        --------->      ----------             |                                     |
|                        |           ----| Clase1 |-----------  |                                     |
|                        |           |   ----------          |  |                                     |
|                   ------------     |                       |  |                                     |
| Instancia2Clase1  |          | --> |  PropiedadDeInstancia |  | <-----------------------------------
|                   ------------     |                       |  |
|                                    -------------------------  |
|                                                               |
-----------------------------------------------------------------

Los compiladores de Java comprueban estas situaciones y generan errores cuando detectan una referencia a un objeto no estático dentro de un método estático.

// para solucionar el error se deberá definir como:
// static int valor = 8;

class Error{

    int valor = 8;

    public static void main(String[] args) {
        valor = 6;    
    }

}

_JavaDevelopment/testjdk_1.8.0_292/src/Error.java


class NoError{

    static int valor = 8;

    public static void main(String[] args) {
        valor = 6;
    }

}

_JavaDevelopment/testjdk_1.8.0_292/src/NoError.java

Ejemplo con propiedades de clase:

El control de una votación en la que se puede presentar un número cualquiera de candidatos.
En cada momento se puede votar a cualquier candidato y se pueden pedir los siguientes datos:

- Nombre de un candidato concreto y el número de votos que lleva hasta el momento
- Nombre del candidato más votado hasta el momento y número de votos que lleva conseguidos.

La clase Votacion, 
Permite almacenar el nombre de un candidato y el numero de votos que lleva, 
además de los métodos necesarios para actualizar el estado del objeto.
Si instanciamos la clase 14veces por ejemplo... 
se podrá llevar el control de votos de 14 candidatos.

¿Cómo contabilizar el número de votos y almacenar el nombre del candidato más votado hasta el momento?
- Crear una clase "MasVotado", que se instancie una sola vez y 
  contenga propiedades para almacenar estos valores,
  junto a métodos para consultarlos y actualizarlos.

Esta solución NO REQUIERE del uso de una nueva clase "MasVotado" o similar, ni necesita un número fijo de instanciaciones para funcionar. Contiene las propiedades y métodos de acceso a la persona más votada dentro de la propia clase Votacion, en la que se vota a cada persona.

Como el nombre y el número de votos de la persona más votada 
hasta el momento es una información GENERAL.- Sólo existe un espacio de almacenamiento de estas variables.
que NO depende únicamente de los votos de un candidato, 
sino de los votos recibidos por todos los candidatos, 
estas propiedades deben ser accesibles, comunes y compartidas por todos.
Estas variables deben ser estáticas (de clase).

_JavaDevelopment/testjdk_1.8.0_292/src/Votacion.java


             -----------------
-------------| Votacion.java |-----------
|            -----------------          |
|                     --------------    |
| VotosMasVotado      |            |    |                            
|                     --------------    |
|                                       |
|                     --------------    |
| PersonaMasVotada    |            |    |
|                     --------------    |
| Existen desde que se ejecuta la app   |
|                            ----------------------- 
| static                     | VotosDelMasVotado() |
| PROPIEDADES / METODOS      -----------------------
|            DE                         |
|           CLASE            ------------------------ 
|        (Generales)         | NombreDelMasVotado() |
|                            ------------------------ 
|_______________________________________|
|                                       |
|                     --------------    |
|        Votos        |            |    |
|                     --------------    |
|                                       |
|                     --------------    |
|        Persona      |            |    |
|                     --------------    |
|                                       |
|                              ----------------------- 
|                              | NombrePersona()     |
|                              ----------------------- 
| Se replican con cada Instanciación    |
|                                  -----------
|    PROPIEDADES / METODOS         | Voto () |
|               DE                 -----------
|            INSTANCIA                  |
|                                  -----------
|               new()              | Votos() |
|                                  -----------
|_______________________________________|


PAQUETES Y ATRIBUTOS DE ACCESO

Los paquetes sirven para agrupar clases relacionada, de esta manera, cada paquete contiene un conjunto de clases.
Las clases que hay dentro de un paquete deben tener nombres diferentes para que se puedan diferenciar entre sí, peor no hay ningún problema en que dos clases que pertenecen a paquetes diferentes tengan el mismo nombre; los paquetes facilitan tanto el agrupamiento de clases como la asignación de nombres.
Cuando no se especifica el nombre del paquete al que pertenece una clase, esta clase pasa a pertenecer al "paquete por defecto".

Primera sentencia de la clase:  package Nombre_Paquete;  package Terminal;

/home/hadoop/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment/testjdk_1.8.0_292/src/Terminal
total 28K
Ordenador.java
Telefono.java
WebTV.java

Estas clases son accesibles desde fuera de paquete, por ser (public) publicas.

package Terminal;
public class Telefono{
    ...
    ...
}

package Terminal;
public class Ordenador{
    ...
    ...
}

package Terminal;
public class WebTV{
    ...
    ...
}

Cuando necesitamos hacer uso de todas o algunas de las clases de un paquete:
- Especificando la clase que se va a utilizar(junto con la referencia de su paquete);
    import Terminal.Ordenador;
- Se indica que se quiere hacer uso (potencialmente) de todas las clases del paquete.
    import Terminal.*;

SÓLO se pueden usar desde fuera de una paqueta las clases definidas como públicas dentro de ese paquete.

import Terminal.Ordenador;
class TerminalOficinaBancaria{
    // podemos utilizar las referencias deseadas a la clase Ordenador
    // podemos referenciar sus propiedades y métodos de manera directa
}

Estos paquetes de utilidades son tan comunes que no es necesario importarlos para usarlos
java.lang.Math
java.lang.String

Otra alternativa es no utilizar la sentencia import y referenciar los objetos con caminos absolutos:
Esto no es muy legible
Terminal.Telefono MiTelefono = new Terminal.Telefono(...); 
--O-J-O--
Actualizar el CLASSPATH con la ruta en donde almacenamos los paquetes: ejemplo en windows 
C:\Paquetes\Terminal
set CLASSPATH = C:\Paquetes\Terminal en autoexec.bat
ó 
CLASSPATH = C:\Paquetes\Terminal

javac --classpath C:\Paquetes\Terminal\TerminalOficinaBancaria.java

_JavaDevelopment/testjdk_1.8.0_292/src/TerminalOficinaBancaria.java

--O-J-O--
atributos de acceso (public) y (private) indican acceso a las propiedades y métodos de una clase desde el exterior a la misma.
Los atributos son de acceso (private) y sólo se puede acceder a ellos (en consulta o modificación) a través de métodos públicos.

----------------------------------------------------------------------------------------
|                |                   |                         | Acceso    | Acceso    |
|                |                   |                         |   desde   |  desde    |
| Tipo de acceso | Palabra reservada | Ejemplo                 | una clase | una clase |
|                |                   |                         | del MISMO | de OTRO   |
|                |                   |                         | PAQUETE   | PAQUETE   |
----------------------------------------------------------------------------------------
|  Privado       |    private        | private int Propiedad   |    NO     |     NO    |
----------------------------------------------------------------------------------------
|Sin Especificar |                   |         int Propiedad   |    SI     |     NO    | ----------------------------------------------------------------------------------------
|  Protegido     |    protected      | protected int Propiedad |    SI     |     NO    | ----------------------------------------------------------------------------------------
|  Público       |    public         | public int Propiedad    |    SI     |     SI    |
----------------------------------------------------------------------------------------

El acceso desde una clase perteneciente al MISMO PAQUETE sólo esta prohibido si el miembro es privado.
El acceso desde una clase perteneciente a OTRO PAQUETE sólo está permitido si el miembro es público:

Ex
package ConversionDeMedidas;
public class ConversionDeDistancias{
    // puede ser referenciada desde un paquete/clase (VentaDeProductos/VentaDeNaranjas)
    // por ser definida como public
    final public double LibrasAKilos = ... ;
}

package VentaDeProductos;
import ConversionDeMedidas.ConversionDeDistancias;
class VentaDeNaranjas{
    ...
    double Kilos = Libras * LibrasAKilos;
}

Los otros atributos tienen sentido en herencia.

MAQUINA EXPENDEDORA
Controlar el funcionamiento de una máquina expendedora sencilla.
Suministra botellas de agua, naranja y coca-cola
Establecer los precios de cada producto
Admite monedas de 1€, y de 10centimos(0.1€).
Definir una máquina con cualquier numero de productos
- Cuantas botellas de agua nos quedan (en el deposito de botellas de agua)
- Cuantas botellas de naranja nos quedan (en el deposito de botellas de naranja)
- Cuantas botellas de coca-cola nos quedan (en el deposito de botellas de coca-cola)
- Cuantas monedas de Euro nos quedan (en el deposito de monedas de Euro)
- Cuantas monedas de 10centimos de Euro nos quedan (en el deposito de monedas de 10centimos de Euro)
Esta clase gestionará un Almacén de elementos reutilizar Almacen.java en MaquinaAlmacen.java

    /*---------------------
    // Propiedades de Instancia
    // Esta forma es más adaptada a la programación orientada a objetos
    // Definidas como private e incorporar los métodos para 
    // obtener sus referencias
    // Algo como: --- pendiente de probar
    private MaquinaAlmacen DepositoAgua = new MaquinaAlmacen((short) 8);

    public MaquinaModeloSencillo getAlmacenAgua(){
    ó 
    public MaquinaModeloSencillo getAlmacen(String TipoAlmacen)
    */


Se podría crear nuevas clases que definieran más productos ó mejor aún
Ampliar esta clase con nuevos productos. --> ver Herencia

Las máquinas definidas o las que podamos crear siguiendo el patron de MaquinaModeloSencillo necesitan un elemento adicional, el control de las monedas.

_JavaDevelopment/testjdk_1.8.0_292/src/MaquinaAlmacen.java
_JavaDevelopment/testjdk_1.8.0_292/src/MaquinaModeloSencillo.java

_JavaDevelopment/testjdk_1.8.0_292/src/MaquinaAutomataEuros.java --> pendiente de picar y de probar el código

HERENCIA

Nos permite crear clases que especializan a otras previamente definidas.

// Publicación es la SuperClase de Libro
// Una SuperClase puede tener cualquier número de SubClases
public class Publicacion {
    private int NumeroDePaginas;
    private float Precio;
}

// Creamos un Libro especifico a partir de la clase Publicacion
// Esta clase extiende de la clase Publicación
// Contiene TODAS las propiedades de la clase Publicación
// Libro es una clase derivada o SubClase de Publicacion.

public class Libro extends Publicacion{
    public String Titulo;
    public String TipoPortada;
    public String ISBN;
    public String NombreAutor;
    public String Editorial;
}
public class Periodico extends Publicacion{
    public String Nombre;
    public String Fecha;

Un libro se define por NumeroDePaginas, Precio, Titulo, TipoPortada, etc...

// Comprobar que un libro contiene las propiedades de la SuperClase como de la SubClase:
public class PruebaLibro {

    public static void main(String[] args){
        Libro MiLibro = new Libro();
        MiLibro.Titulo = "Este libro es mi libro";
        MiLibro.TipoPortada = "Dura";
        MiLibro.ISBN = "9788478975495";
        MiLibro.NombreAutor = "Jesus Bobadilla";
        MiLibro.Editorial = "RA-MA";
        MiLibro.NumeroDePaginas = 589;
        MiLibro.Precio = 190.00f;
    }
    
}
                                     ---------------
                            -------> | Publicacion | <------
                            |        ---------------       |
                            |                              |
                        ---------                    -------------
                        | Libro |                    | Periodico |
                        ---------                    -------------

El mecanismo de herencia NO SÓLO actuá sobre las propiedades, lo hace sobre todos los miembros
(métodos y propiedades) de las clases, de esta manera las clases se pueden completar con métodos

_JavaDevelopment/testjdk_1.8.0_292/src/Publicación.java
_JavaDevelopment/testjdk_1.8.0_292/src/Libro.java
_JavaDevelopment/testjdk_1.8.0_292/src/Periodico.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaLibroPeriodico.java

Las SubClases heredan todos los miembros de su SuperClase, aunque NO todos los miembros tienen porque ser accesibles.
En particular los miembros privados de una SuperClase NO SON directamente accesibles en sus SubClases.
Los miembros protegidos de la SuperClase si son accesibles a SubClases situadas en paquetes diferentes a la SuperClase
Las propiedades de la SuperClase NO son directamente accesibles desde las SubClases Periodico y Libro
// Es mejor no usar la ocultación en el diseño de las clases.
Existe la posibilidad de "ocultar" propiedades de la SuperClase, definiendo propiedades con el mismo nombre en la SubClase.
En este caso en la SubClase, al referenciar directamente el nombre nos referimos a la propiedad de la SubClase.
Existe la posibilidad de "ocultar" métodos similar al de las propiedades y se denomina redefinición, nos permite volver a definir el comportamiento de los métodos de la SuperClase, además su atributo de acceso debe ser el mismo o menos restrictivo que el original.
para referirnos a las propiedades y a los métodos de la SuperClase tenemos que hacerlo con super.Nombre

----------------------------------------------------------------------------------------
|                |                   |                         | Acceso    | Acceso    |
|                |                   |                         |   desde   |  desde    |
| Tipo de acceso | Palabra reservada | Ejemplo                 | una clase | una clase |
|                |                   |                         | SubClase  | SubClase  |
|                |                   |                         | del MISMO | de OTRO   |
|                |                   |                         | PAQUETE   | PAQUETE   |
----------------------------------------------------------------------------------------
|  Privado       |    private        | private int Propiedad   |    NO     |     NO    |
----------------------------------------------------------------------------------------
|Sin Especificar |                   |         int Propiedad   |    SI     |     NO    | ----------------------------------------------------------------------------------------
|  Protegido     |    protected      | protected int Propiedad |    SI     |     SI    | ----------------------------------------------------------------------------------------
|  Público       |    public         | public int Propiedad    |    SI     |     SI    |
----------------------------------------------------------------------------------------

CONSTRUCTORES DE LAS SubClaseS

En las clases derivadas de una SuperClase, los constructores, además de establecer el estado inicial
de su propia SubClase deben establecer el estado inicial de la SuperClase.

Si se usa super, debe ser (obligatoriamente) la primera sentencia del constructor.
        super(parámetros) // donde puede haber cero o más parámetros

Cuando en un constructor de una SubClase no se utiliza la sentencia "super", el compilador inserta 
automáticamente super() como primera instrucción.
Esto puede dar lugar a errores de compilación, puesto que si en la SuperClase hemos definido algún constructor y no hemos definido super(), el compilador no encontrará este constructor.
Si en la SuperClase no hemos definido ningún constructor, no existirán problemas, 
puesto que super() es el constructor por defecto que crea el compilador cuando nosotros no definimos otro.

En cualquier caso, cuando se necesite, se recomienda poner explicitamente la llamada super().


 // Constructores
    // vacio o sin parámetros, se llamá automaticamente si no ponemos "super" en algun constructor
    // de una SubClase
    Publicacion2(){
        NumeroDePaginas = 2;
        Precio = 0f;
    }
    // firma int
    Publicacion2(int NumeroDePaginas){
        setNumeroDePaginas(NumeroDePaginas);
    }
    // firma float 
    Publicacion2(float Precio){
        setPrecio(Precio);
    }
    // firma int, float 
    Publicacion2(int NumeroDePaginas, float Precio){
        // Invoca al constructor de la misma clase que coincide en firma con la llamada
        // Este invoca al constructor Publicacion2(int NumeroDePaginas)
        this(NumeroDePaginas);
        setPrecio(Precio);
    }
    // firma float, int
    Publicacion2(float Precio, int NumeroDePaginas){
        // Invoca al constructor de la misma clase que coincide en firma con la llamada
        // Este invoca al constructor Publicacion2(int NumeroDePaginas, float Precio)
        this(NumeroDePaginas, Precio);
    }

No es muy habitual usar el indicador final ya que restringe la posibilidad de reutilizar las clases
usando el mecanismo de herencia.

Si utilizamos el modificador final al definir una clase evitamos que se puedan construir clases derivadas de la misma:

public final class NombreClase{
    // Contenido de la clase
}

    Constructores - 
    int NumeroDePaginas; float Precio;
    String Titulo; String TipoPortada; String ISBN; String NombreAutor; String Editorial;
    String Nombre; String Fecha;

_JavaDevelopment/testjdk_1.8.0_292/src/Publicación2.java
_JavaDevelopment/testjdk_1.8.0_292/src/Libro2.java
_JavaDevelopment/testjdk_1.8.0_292/src/Periodico2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaLibroPeriodico2.java

    Constructores - 
    Color Color; int[] Posicion;
    double Radio;
    double[] Lados

_JavaDevelopment/testjdk_1.8.0_292/src/FiguraGeometrica.java
_JavaDevelopment/testjdk_1.8.0_292/src/Circulo.java
_JavaDevelopment/testjdk_1.8.0_292/src/Rectangulo.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaFiguraGeometrica.java

    Constructores - aquí me quedo una firma mal revisar
    Color Color; byte Ruedas; short Cilindrada; short Potencia;
    byte Ejes;
    byte Ocupantes;

// Estas clases las he escrito creando mis constructores - 
// aunque algunos estan comentados, puede que las firmas no esten correctas, 
// es mejor revisarlas con calma en otro momento

_JavaDevelopment/testjdk_1.8.0_292/src/Vehiculos.java
_JavaDevelopment/testjdk_1.8.0_292/src/Camion.java
_JavaDevelopment/testjdk_1.8.0_292/src/Motocicleta.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaVehiculos.java

POLIMORFISMO
Permite que clases de diferentes tipos puedan ser referenciadas por una misma variable.
La instancia "MiFigura" de la clase FiguraGeometrica, podrá referenciar a propiedades y métodos implementados
en las clases Circulo y Rectangulo.

------------                  --------------------      
| MiFigura |-------->>> ------| FiguraGeometrica |----------
------------            |     --------------------         |
      |                 |                            --------------
      |                 |                   Miembros |            | Propiedades y Métodos
      |                 |                            --------------
      |                 |                                  |
      |                 ------------------------------------
      |
      |                       -----------
      |------------->>> ------| Circulo |-------------------
      |                 |     -----------                  |
      |                 |                            --------------
      |                 |                   Miembros |            | Propiedades y Métodos
      |                 |                            --------------
      |                 |                                  |
      |                 ------------------------------------
      |
      |                       --------------
      -------------->>> ------| Rectangulo |----------------
                        |     --------------               |
                        |                            --------------
                        |                   Miembros |            | Propiedades y Métodos
                        |                            --------------
                        |                                  |
                        ------------------------------------

Las clases Circulo y Rectangulo implementan un método llamado Perimetro que calcula el perimetro 
de la figura geométrica: Circulo => A = π*r^2, Rectangulo => Lado*Lado

------------                  --------------------      
| MiFigura |-------->>> ------| FiguraGeometrica |----------
------------            |     --------------------         |
      |                 |                            --------------
      |                 |                   Miembros |            | Propiedades y Métodos
      |                 |                            --------------
      |                 |                                  |
      |                 |                            --------------
      |                 |                  Perimetro |            | 
      |                 |                            --------------
      |                 |                                  |
      |                 ------------------------------------
      |
      |                       -----------
      |------------->>> ------| Circulo |-------------------
      |                 |     -----------                  |
      |                 |                            --------------
      |                 |                   Miembros |            | Propiedades y Métodos
      |                 |                            --------------
      |                 |                                  |
      |                 |                            --------------
      |                 |                  Perimetro |            | 
      |                 |                            --------------
      |                 |                                  |
      |                 ------------------------------------
      |
      |                       --------------
      -------------->>> ------| Rectangulo |----------------
                        |     --------------               |
                        |                            --------------
                        |                   Miembros |            | Propiedades y Métodos
                        |                            --------------
                        |                                  |
                        |                            --------------
                        |                  Perimetro |            | 
                        |                            --------------
                        |                                  |
                        ------------------------------------
La referencia MiFigura de tipo FiguraGeometrica podrá invocar al método Perimetro de la clase Circulo o 
                                                              al método Perimetro de la clase Rectangulo,
dependiendo de, si en tiempo de ejecución, está referenciando a una instancia de la clase Circulo o está referenciando a una instancia de la clase Rectangulo.

La determinación del método Perimetro que se va a invocar (el de la clae Circulo ó Rectangulo) no se realiza en la compilación sino en TIEMPO DE EJECUCIÓN, lo que hace el polimorfismo un mecanismo de programación muy potente.

Ex: 
Un editor gráfico en el que el usuario puede dibujar figuras geométricas bidimensionales tales como circulos, rectangulos, pentagonos, triangulos, etc.
Además, dentro de las opciones de la herramienta, existe un botón que que al ser pulsado nos muestra en una ventana el valor del perimetro de la figura seleccionada.

No conocemos a priori las figuras que el usuario dibujará, eso es algo que ocurre en tiempo de ejecución,
al igual que no podemos saber por adelantado de qué figura o figuras solicitará conocer el perimetro.
En un momento dado, mientras un usuario utiliza el editor gráfico, existirá una estructura de datos que
contendrá las figuras dibujadas:

----------------------      -------
| MiFigura |    |    |......|     |
----------------------      ------- 
     |        |    |            |
     |        |    |            |       -----------
     |        |    |            ----->>>| Circulo |--------------
     |        |    |                |   -----------             |
     |        |    |                ----|       -----------     |
     |        |    -------------------------->>>| Circulo |--------------
     |        |                             |   -----------             |
     |        |                             |       --------------      |
     |        ----------------------------------->>>| Rectangulo |------------
     |                                          |   --------------           |
     |                                          |                      --------------
     |                                          |            Miembros  |            |
     |                                          |                      --------------
     |                                          |                             |
     |                                          |                       --------------
     |                                          |        -------------- |            |
     ------------------------------------------>>> ------| Rectangulo |---------
                                            |            --------------        |
                                            |                            --------------
                                            |                   Miembros |            | Propiedades y Métodos
                                            |                            --------------
                                            |                                  |
                                            |                            --------------
                                            |                  Perimetro |            | 
                                            |                            --------------
                                            |                                  |
                                            ------------------------------------
El vector MiFigura contendrá referencias a objetos de tipo FiguraGeometrica
(FiguraGeometrica[]MiFigura = new Figura[100]).
Según el usuario, en tiempo de ejecución, seleccione una figura geométrica u otra se invocará a un método Perimetro u otro.

Reglas de polimorfismo: 

La invocación a un método de una SubClase debe realizarse a través de una referencia a la SuperClase; 
es decir, 
p = LaFigura.Perimetro(), esto es adecuado 
p = ElCirculo.Perimetro(). esto No es adecuado

El método llamado debe ser también un miembro de la SuperClase; en nuestro ejemplo, el método Perimetro debe existir también en la clase FiguraGeometrica.

La firma del método debe ser igual en la SuperClase que en las clases SubClases; es decir, el nombre del método y el número y tipos de sus parámetros debe ser igual en las clases FiguraGeometrica, Circulo, Rectangulo, etc.

El tipo de retorno del método (que se utilizará de forma polimórfica) debe ser igual en la SuperClase que en las SubClases.

El atributo de acceso del método no debe ser más restrictivo en las SubClases que en la SuperClase.

se crea el método Perimetro() este método calcula el perimetro de una figura - 
El método de la SuperClase Nunca se va a ejecutar, se ejecutará el código de los métodos de las SubClases.


_JavaDevelopment/testjdk_1.8.0_292/src/PolimorfismoFiguraGeometrica.java
_JavaDevelopment/testjdk_1.8.0_292/src/PolimorfismoCirculo.java
_JavaDevelopment/testjdk_1.8.0_292/src/PolimorfismoRectangulo.java

// --O-J-O-- esta clase nos muestra la forma de crear los objetos revisar con cuidadao

Dede una SuperClase NO SE TIENEN visibilidad de los miembros de las SubClases (aunque al controrio no haya problema)
Esto genera errores de compilación: MiCirculo.getRadio() y MiRectangulo.getLados()
Los métodos getRadio() y getLados() pertenece a la clase PolimorfismoCirculo y PolimorfismoRectangulo respectivamente, y 
MiCirculo y MiRectangulo son propiedades de tipo PolimorfismoFiguraGeometrica.

Para solucionar esto tenemos dos posibilidades:

// 1. Crear una instancia de la clase PolimorfismoCirculo y asignarle la referencia de MiCirculo usando Casting
// 2. Utilizar Casting sin crear explicitamente una instancia de la clase PolimorfismoCirculo.

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaPolimorfismoFiguraGeometrica.java

CLASES ABSTRACTAS E INTERFACES
Métodos abstractos.

Un método abstracto se declara pero no se define, no usa{}, usa la palabra abstract y termina con (;).
No se deben definir como final ya que no se prodría redefinir en las SubClases, estas tendrán este método como abstracto y nunca podrían ser instanciadas.

    Ex: declaración de un método
    public double Perimetro(){
        System.out.println("Perimetro de SuperClase NUNCA ME DEBO EJECUTAR");
        return 0d;
    }
    Ex: declaración de un método abstracto
    public abstract double Perimetro();

Un Clase es abstracta cuando al menos tiene un método es abstracto:
    public abstract class ClaseAbstracta{}

Se pueden definir variables de clase abstract:
    ClaseAbstracta MiVariable;

Se pueden definir variables de clase abstract, pero NO instanciarlas;
    ClaseAbstracta MiVariable = New ClaseAbstracta();

Se puede utilizar clases abstractas como SuperClase
    public abstract class SubClaseAbstracta extend ClaseAbstracta(){
        // definir parte de los métodos abstractos
    }

    public class ClaseNoAbstracta extends SubClaseAbstracta{
        // definir TODOS los métodos abstractos que tenga la SuperClase
    }

    ClaseNoAbstracta MiInstancia = new ClaseNoAbstracta();

Se puede diseñar aplicaciones que contengan una serie de clases abstractas y codificar las mismas sin entrar en la definición de los detalles del código de los métodos. 
La App/app queda bien estructurada, definida y consistente (podemos compilarla), a partir de este punto de partida resulta mucho más sencilla la fase de implementación.

// Estas clases las he escrito usando los constructores como estan en el libro - efectos de comprensión

_JavaDevelopment/testjdk_1.8.0_292/src/AbstractaVehiculos.java
_JavaDevelopment/testjdk_1.8.0_292/src/AbstractaMotocicleta.java
_JavaDevelopment/testjdk_1.8.0_292/src/AbstractaCamion.java

Esta clase tiene un método abstracto y utiliza polimorfismo
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaAbstractaVehiculos.java

INTERFACES

Son colecciones de constantes y métodos abstractos.
Los métodos son siempre públicos y abstractos(no es necesario definirlos como tal), y 
las constantes son siempre públicas, estáticas y 
por supuesto, final (tampoco es necesario especificar sus atributos de acceso y modificadores).
Proporcionan un mecanismo de herencia múltiple que no puede ser utilizado empleando únicamente clases.

Ex: // contiene sólo constantes
public interface DatosCentroDeEstudios {
    byte NumeroDePisos = 5;
    byte NumeroDeAulas = 25;
    byte NumeroDeDespachos = 10;
    ...
    resto de constantes
}

Ex: // contiene sólo métodos
public interface CalculosCentroDeEstudios {
    short NumeroDeAprobados(float[] Notas);
    short NumeroDeSuspensos(float[] Notas);
    float NotaMedia(float[] Notas);
    float Varianza(float[] Notas);
    ...
    resto de métodos
}

Ex: // contiene constantes y métodos
public interface CentroDeEstudios {
    byte NumeroDePisos = 5;
    byte NumeroDeAulas = 25;
    byte NumeroDeDespachos = 10;
    // resto de constantes
    short NumeroDeAprobados(float[] Notas);
    short NumeroDeSuspensos(float[] Notas);
    float NotaMedia(float[] Notas);
    float Varianza(float[] Notas);
    // resto de métodos

}

Ex: // Definir una interface basada en otra. - extends.
public interface CentroDeEstudios extends DatosCentroDeEstudios{
    short NumeroDeAprobados(float[] Notas);
    short NumeroDeSuspensos(float[] Notas);
    float NotaMedia(float[] Notas);
    float Varianza(float[] Notas);
    // resto de métodos
}

Definir SuperInterfaces y SubInterfaces.
Una Interfaz puede extender simultáneamente a varios SuperInterfaces, 
lo que supone una aproximación a la posibilidad de realizar herencia múltiple.

public interface CentroDeEstudios extends DatosCentroDeEstudios, CalculosCentroDeEstudios{
    // otros posibles métodos y constantes
}

Para poder utilizar los miembros de un interfaz es necesario implementarlo en una clase,
Cuando se implementa un interfaz con una clase no abstracta debemos implementar todos y cada uno de sus métodos
Un método abstracto se declara pero no se define, no usa{}, usa la palabra abstract y termina con (;).
Es obligatorio definir todos su métodos aunque no se desarrollen
se emplea la palabra reservada implements para indicarlo:

public class CCentroDeEstudios implements CentroDeEstudios {}

_JavaDevelopment/testjdk_1.8.0_292/src/CCentroDeEstudios.java
_JavaDevelopment/testjdk_1.8.0_292/src/CalculosCentroDeEstudios.java
_JavaDevelopment/testjdk_1.8.0_292/src/CentroDeEstudios.java
_JavaDevelopment/testjdk_1.8.0_292/src/DatosCentroDeEstudios.java


      ------------ ItfImpresion                            ------------ ItfImpresion2
------| Interfaz |------------------                 ------| Interfaz |------------------
|     ------------                 |                 |     ------------                 |
|       Imprimir             --------------          |      ImprimirBonito        -------------- 
|                            |            |          |                            |            |
|                            --------------          |                            --------------
|                                  |                 |                                  |
------------------------------------                 ------------------------------------
        ^^                   ^^                                 ^^
        ||                   ||________________                 ||
        ||                                     |                ||
   --------------- ItfPositivoImpresion        |                ||
---|             |-----------------            |                ||
|  ---------------                |            |                ||
|                            --------------    |                ||
|      Imprimir              |            |    |                ||
|                            --------------    |                ||
|                                 |            |________________||
-----------------------------------                           ------------ ItfNeutro
        ^^                                              ------|          |-----------------
        ||                                              |     ------------                |
        ||                                              |                           ------------
   --------------- ItfNegativoImpresion                 |                           | Imprimir |
---|             |-----------------                     |                           ------------
|  ---------------                |                     |                                 |
|                            --------------             |                          ------------------
|      Imprimir              |            |             |                          | ImprimirBonito |
|                            --------------             |                          ------------------ |                                 |                     |                                 | -----------------------------------                     -----------------------------------

El interfaz ItfImpresion así como el interfaz ItfImpresion2, se utiliza como superinterfaz de diversas clases, al igual que una clase puede ser superclase de varias clases derivadas.

_JavaDevelopment/testjdk_1.8.0_292/src/ItfImpresion.java
_JavaDevelopment/testjdk_1.8.0_292/src/ItfImpresion2.java

Clases que implementan las interfaces: ItfPositivoImpresion, ItfNegativoImpresion e ItfNeutro.
ItfNeutro utiliza el mecanismo de herencia múltiple (implementando simultáneamente dos interfaces).

_JavaDevelopment/testjdk_1.8.0_292/src/ItfNegativoImpresion.java
_JavaDevelopment/testjdk_1.8.0_292/src/ItfPositivoImpresion.java

Clase para probae el funcionamiento de las clases
_JavaDevelopment/testjdk_1.8.0_292/src/ItfPrueba.java

// La clase ItfNeutro implementa los dos interfaces, 
// consiguiendo herencia multiple (de métodos abstractos):
_JavaDevelopment/testjdk_1.8.0_292/src/ItfNeutro.java

// se hace uso del polimorfismo
_JavaDevelopment/testjdk_1.8.0_292/src/ItfPrueba2.java

EXEPCIONES PREDEFINIDAS

// ex: división por cero, acceso a un String declarado pero no instanciado

Denominador = 
if ( Denominador != 0 ){
    Numerador = ..............
    Resultado = Numerador / Denominador;
} else
system.out.println("No se puede realizar la división por cero");


Se escribe el código que habría que ejecutar si la situación "excepcional", se produce:
    ....
    Numerador = ..............
    Denominador = ....
    Resultado = Numerador / Denominador;
    ....
Si existe excepcion,  System.out.println("No se puede realizar la división");

Este tipo de codificación es muco más fácil de entender, ya que no es necesario incluir las instrucciones condicionales que verifican si puede darse la situación de excepción. Se puede separar de esta forma la lógica del programa de las instrucciones de control de errores.

Las exepcion son objetos (clases), que se crean cuando se produce una situación extraordinaria en la ejecución del programa.
La SuperClase de todas las excepciones es la clase Throwable.  (2 constructores y 7 métodos).
La clase Throwable tiene dos clases derivadas: Error y Excepcion.

La clase Excepcion sirve como superclase para crear excepciones de propósito especifico (adaptadas a nuestras necesidades).
Ex: Si estamos diseñando una clase que lee secuencialmente bytes en una cinta digital de datos, podemos crear la excepcion FinDeCinta que se produce cuando el dispositivo físico ha alcanzado el final de la cinta.
Ex: Implementación de una clase de envio de datos a un satélite no geoestacionario, donde convendía incluir una excepcion FueraDeCobertura que se produzca cuando el satélite se encuentre fuera del alcance de nuestra antena parabólica. 
Ex: Al escribir un driver de impresora, se puede crear una Excepcion para el FinDePapel.
Ex: Fin DeDatos en una lectura secuencial.
Existen exepciones predefinidas para el uso de ficheros de SQL, etc. 
De la subclase RuntimeException no es necesario realizar un tratamiento explicito ya que existen pocas posibilidades de recuperar situaciones anomalas de este tipo.

La clase Error sirve como superclase para crear una serie de clases derivadas ya definidas que nos informan de situaciones anormales relacionadas con errores de muy díficl recuperación producidos en el sistema. No es obligatorio tratar estas excepciones, ya que en la ejecución de una aplicación probablemente nunca se produzcan estas situaciones anormales, sin embargo, si que es obligatorio hacer un tratamiento explicito de las excepciones derivadas de la clase Exception.

Entre las clases derivadas de RuntimeException se encuentran:

ArithmeticException: Cuando ocurre una operación aritmética errónea, Ex división entre cero; con los valores reales no se produce esta excepcion.
ArrayStoreException: Intento de almacenar un valor de tipo erróneo en una matriz de objetos.
Illegal ArgumentException: Se le ha pasado un argumento ilegal o inapropiado a un método.
IndexOutOfBoundsException: Cuando algún indice(por ejemplo de array o String) esta fuera de rango.
NegativeArraySizeException: Cuando se intanta crear un array con un índicce negativo.
NullPointerException: Cuando se utiliza como apuntador una variable con valor null.

  -------------
  | Throwable |
  -------------
  | Exception |
  -------------
    IOException - Obligatorio realizar tratamiento explicito de las excepciones.
    SQLException - Obligatorio realizar tratamiento explicito de las excepciones.                             
    AWTException - Obligatorio realizar tratamiento explicito de las excepciones.
    RuntimeException - NO Obligatorio

  -------------
  | Throwable |
  -------------
    | Error |
    ---------
    AWTError - NO Obligatorio
    LinkageError - NO Obligatorio
    ThreadDeat - NO Obligatorio
    VirtualMachineError - NO Obligatorio

    Bloque de "intento" - try - Código del programa susceptible de causar cierto tipo de excepciones.
    Bloque inferior - catch(TipoDeExcepcion Identificador) - Instrucciones de control de situaciones excepcionales.

    try{
       // Instrucciones susceptibles de causar cierto ditpo de excepciones 
    } catch (TipoDeExcepcion Identificador) {
       // Instrucciones de control de situaciones excepcionales
    }

       _JavaDevelopment/testjdk_1.8.0_292/src/Excepcion1.java

    Se ejecutan las instrucciones del bloque try hasta que se produzca la situación de excepción de TipoDeExcepcion; 
    Habitualmente, no se producirá la excepción y se ejecutarán todas las instrucciones del bloque try.
    Si se produce la excepcion, se pasa a ejecutar las instrucciones del bloque catch y posteriormente, las instrucciones siguientes al bloque catch.
    Si NO se produce la excepcion, No se ejecutan las instrucciones del bloque catch.

    Si se produce más de una excepción, se puede asociar varios bloques catch a un mismo bloque try.

    try {
        // Instrucciones susceptibles de causar cierto tipo de excepciones
    } 
    catch (TipoDeExcepcion1 Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcion1
    }
    catch (TipoDeExcepcion2 Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcion2
    }
    catch (TipoDeExcepcionN Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcionN
    }
    
    No se pueden poner instrucciones entre los bloques catch.
    Si ocurre una excepcion en las instruccione del bloque try, 
    se recorren en orden los bloques catch hasta que se encuentra uno con el mismo tipo 
    o un tipo que es SuperClase de la excepcion que ha llegado.
    Se ejecutan únicamente las instrucciones del bloque catch que cumple los requisitos(si alguno lo cumple).


    try {
        // Instrucciones susceptibles de causar cierto tipo de excepciones
    } 
    catch (NullPointerException e) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo NullPointerException
    }
    catch (RuntimeException e) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo RuntimeException
       // ó de una clase derivada del mismo (distinta a NullPointerException)
    }
    catch (Exception e) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo Exception
       // ó de una clase derivada del mismo (distinta a RuntimeException)
    }

    Si cambiamos el orden (en cualquiera de sus posibles combinaciones) de los bloques catch del ejemplo nos encontramos con un error de compilación, puesto que al menos un bloque catch no podra ejecutarse nunca.

    Resulta habitual utilizar varios bloques catch correspondientes a excepciones con un mismo nivel de herencia, por ejemplo con SubClases de RuntimeException:

    _JavaDevelopment/testjdk_1.8.0_292/src/Excepcion2.java

    El Bloque finally

    try {
        // Instrucciones susceptibles de causar cierto tipo de excepciones
    } 
    catch (TipoDeExcepcion1 Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcion1
    }
    catch (TipoDeExcepcionN Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcionN
    }
    finally{
       // Se utiliza para evitar dejar ficheros abiertos, comunicaicones sin terminar, recursoso bloqueados..etc
       // Instrucciones siempre se ejecutan después de las del catch seleccionado.
    }
    
    Propagación de exepciones: Normalmente dentro de un try contienen llamadas a métodos, que a su vez pueden realizar llamadas a 
    otros métodos y así sucesivamente. Cualquiera de los métodos llamados puede provocar una excepción y cualquiera de los métodos
    puede o no tratarse con bloques catch.
    Una excepcion no tratada en un bloque se propaga hacia el bloque llamante.
    Este mecanismo de propagación continúa mientras no se trate la excepción o se llegue al método de nivel superior.
    Si la excepción no se trata en el método de nivel superior, se imprime un error por consola.

    Es conveniente que si se trata una excepcion a un nivel, esta sea tratada a niveles superiores.
    Para propagar de forma explicita una excepcionse emplea la palabra throw seguida del objeto excepcion:
    Ex: al leer un fichero y escribir en otro fichero, y tenemos un error de lectura, además de tratarla en ese nivel, debemos tratarla a nivel superior de tal forma que se informe al usuario y le permita hacer un nuevo intento si lo desea.

    // el método llamante hace tratamiento de la excepcion
    try {
        // Origen. copiaFichero(destino)
    } 
    catch (IOException e) {
       // System.out.println("Error de lectura, intentelo de nuevo");
    }
    
    // después de tratar la excepcion, se propaga con throw
    public void copiaFichero(tipofichero destino){
        try {
            // código
        } 
        catch (IOException e) {
            // cerrar ficheros, etc
            throw e;
        }
    }    

El estado de las instancias de la clase Throwable se compone de:
String que sirve de mensaje indicando las caracteristicas de la excepcion y 
pila de ejecución que contiene la relación de métodos que se encuentran en ejecución en el momento en el que se produce la excepcion.

Throwable - métodos:

getMessage(): Devuelve como String el mensaje del error almacenado en este objeto (nombre y referencia de la excepcion).
printStackTrace(): Imprime por el dispositivo de salida de errores (consola), el mensaje y la pila de ejecución. Este método está sobrecargado para poder sacar el resultado por diferentes salidas: printStackTrace(PrintStream s) printStackTrace(PrintWriter s)
toString(): Devuelve como String una descripción corta del objeto.

            catch (IndexOutOfBoundsException e) { 
                System.out.println("IndexOutOfBoundsException - Indice fuera del array");
                // Imprime un mensaje acerca de la excepcion, seguido de la pila de ejecución
                // de los métodos del programa indicando la línea donde se produce la excepcion
                e.printStackTrace();
            }

_JavaDevelopment/testjdk_1.8.0_292/src/Excepcion1.java
_JavaDevelopment/testjdk_1.8.0_292/src/Excepcion2.java
_JavaDevelopment/testjdk_1.8.0_292/src/Excepcion3.java

El mecanismo de excepciones es muy lento en ejecución comparado con el uso de instrucciones condicionales.
Aunque el mecanismo de excepciones es elegante, debemos utilizarlo con prudencia: únicamente en situaciones que realmente son excepcionales.

Ex: Se debe hacer un análisis de si una exepción que definimos, se puede tratar por una excepcion ó con una instruccion condicional 
Código de barras ilegible - dependiendo de la frecuencia - con una instrucción condicional
Código de barras NO valido(corresponde a un pase caducado) - dependiendo de la frecuencia - 
Código de barras utilizado en un periodo de tiempo demasiado breve - dependiendo de la frecuencia con una excepcion
etc... 

Una excepción definida por el programador hereda de la clase Exception.
Se incluye como mínimo el constructor vacio y 
otro que contenga un String como argumento, inicializado automáticamente con el nombre de la clase (en Throwable), el texto en este constructor se añadirá al nombre de lal clase insertado por la SuperClase.

_JavaDevelopment/testjdk_1.8.0_292/src/ExcepcionPropia.java
_JavaDevelopment/testjdk_1.8.0_292/src/ExcepcionPropiaClase.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaExcepcionPropia.java

Otro ejemplo de excepciones:
Objeto Excepcion: Define la situación de error: _JavaDevelopment/testjdk_1.8.0_292/src/ExcepcionMatricula.Java

Objeto Clase que levanta la excepcion: Reconocimiento y comunicación de la situación de error, junto con la creación del objeto excepcion: _JavaDevelopment/testjdk_1.8.0_292/src/ExcepcionMatriculaValidar.java
        // tiene un método que compara una posición de un substring dado con una expresión regular [A-Za-Z], pasada por parametro al método matches
        matricula.substring(0, 1).matches("[A-Za-z]")
        expresiones regulares a partir de v1.4JDK

Objeto Clase que recoge la excepcion: Recibe la situación de error y trata de recuperar la situación: _JavaDevelopment/testjdk_1.8.0_292/src/PruebaExcepcionMatricula.java

-----------------------------                                                --------------------------------
| ExcepcionMatriculaValidar |                                                | PruebaExcepcionMatricula     |
-----------------------------------------------------------------            --------------------------------
| ...                                                           |            |                              |
| throw new ExcepcionMatricula(ExcepcionMatricula.MAL_TAMANIO); |            | try{                         |
| ...                                                           |            | ...        |                 |
| throw new ExcepcionMatricula(ExcepcionMatricula.MAL_LETRA);   |            | ...        |                 |
| ...                                                           |            | ...        |                 |
| ...                                                      <-------------------------------                 |
| ...                                                           |            | ...        |                 |
| ...                                                           |            | }          v                 |
-----------------------------------------------------------------            --------------------------------
                                                                             |                              |
                                ----------------------                       |                              |
                                | ExcepcionMatricula |                       | catch (ExcepcionMatricula e){|
                                ----------------------                       |                              |
                                |                    |                       |                              |
                                | --------------     |                       |                              |
                                | | MalFormada |     |               ----------->...........                |
                                | --------------     |               |       | ............                 |
                                |       |            |               |       | ............                 |
                                |       |      ---------------       |       | ............                 |
                                |       ------>| getProblema | ------        |                              |
                                |              ---------------               | }                            |
                                |                    |                       --------------------------------
                                ----------------------                       

INTERFAZ GRÁFICO DE USUARIO

GUI que se encuentran englobados dentro de Java Foundation Classes (JFC), que proporciona:
    AWT: Abstract Window Toolkit proporciona los componentes básicos de I/O. 
    Swing: Recoge la mayor parte de la funcionalidad de AWT.
    Imgenes 2D
    Servicio de Impresión
    Soporte para funciones Drag-and-Drop 
    Funciones de accesibilidad
    etc.


    AWT: Abstract Window Toolkit proporciona los componentes básicos de I/O. 
    Proporciona entre otras:
    la clase Window.
    la clase Frame derivada de Window.

    Jerarquía:

    ----------
    | Object |              java.lang
    ----------
        |            ---
    -------------      |
    | Component |      |
    -------------      |
        |              |
    -------------      |
    | Container |      |
    -------------      |
        |              |--------java.awt
    ----------         |
    | Window |         |
    ----------         |
        |              |
    ---------          |
    | Frame |          |
    ---------          |
        |---------------
    ---------
    | JFrame |               javax.swing
    ---------

Todos los objetos tienen a Object como la SuperClase
La clase abstracta Component proporciona una representación gráfica susceptible a ser representada en un dispositivo de salida, se usa a través de las subclases.
Container deriva de Component y añade la funcionalidad de poder contener otros componentes AWT (por ejemplo varios botones, cajas de texto, etc.)
Window proporciona una ventana gráfica sin bordes ni posibilidad de incluir barras de menú.
Frame es derivada de window pero no presenta las restricciones de Window (puedo incluir barras de menu)
JFrame es la version de Frame Proporcionada por swing. (es más compleja para usar), proporciona mayor funcionalidad que sus superclases de AWT.

https://docs.oracle.com/javase/8/docs/api/index.html?java/awt/Frame.html
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFrame.java
_JavaDevelopment/testjdk_1.8.0_292/src/MyFrame.java
_JavaDevelopment/testjdk_1.8.0_292/src/MyFrame1.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaMyFrame.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaMyFrame1.java

Posicionamiento de múltiples Ventanas, setLocation, heredado de Component.
Sobrecargado y admite dos tipos de parámetros de entrada: es necesario suministrar las coordenadas bidimensionales.
    estas situan la esquina superior izquierda de la ventana respecto a su componente padre
    public void setLocation(int x, int y)
    public void setLocation(Point p)

        UnFrame.setLocation(new Point(100, 200));

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPoint.java
_JavaDevelopment/testjdk_1.8.0_292/src/MyFramePoint.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaMyFramePoint.java

        PANELES Y OBJETOS DE DISPOSICION
        LAYOUTS


    AWT: Abstract Window Toolkit proporciona los componentes básicos de I/O. 
    Proporciona entre otras:
    la clase Window.
    la clase Frame derivada de Window.

    Jerarquía:
               ----------
               | Object |                                   java.lang
               ----------
                   |            --------------------
             -------------                          |
             | Component |                          |
             -------------                          |
          _________|__________                      |
         |                    |                     |
    ----------          -------------               |
    | Button |          | Container |               |
    ----------          -------------               |
                         ______|_____               |
                        |            |              |--------java.awt
                    ---------    ----------         |
                    | Panel |    | Window |         |
                    ---------    ----------         |
                                     |              |
                                 ---------          |
                                 | Frame |          |
                                 ---------          |
                                     |---------------
                                 ---------
                                 | JFrame |               javax.swing
                                 ---------

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassButton.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassButtonPanel.java

Utilización básica de PANELES

 - Flexibilidad Diseño GUI's -

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanel.java

Cada Panel que creamos tiene asociado, implicita o explicitamente un tipo de disposicion ("layout")
Layouts (default FlowLayout, BorderLayout, GridLayout)

default FlowLayout, con los elementos centrados en el panel.
BorderLayout, 
GridLayout, 

Para establecer una disposición de manera explicita, podemos recurrir al método setLayout(heredado de Container).
Instanciar nuestro panel indicando directamente el layout deseado.

    Panel MiPanel = new Panel (new FlowLayout());
    OtroPanel.setLayout(new FlowLayout());

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelFlowLayout.java

        FlowLayout PosicionamientoSecuencial = new FlowLayout();
        PnlPal.setLayout(PosicionamientoSecuencial);

        FlowLayout PosicionamientoLEFT = new FlowLayout(FlowLayout.LEFT);
        PnlPal.setLayout(PosicionamientoLEFT);

        FlowLayout PosicionamientoRIGHT = new FlowLayout(FlowLayout.RIGHT);
        PnlPal.setLayout(PosicionamientoRIGHT);

        FlowLayout PosicionamientoCENTER = new FlowLayout(FlowLayout.CENTER);
        PnlPal.setLayout(PosicionamientoCENTER);

        FlowLayout PosicionamientoLEADING = new FlowLayout(FlowLayout.LEADING);
        PnlPal.setLayout(PosicionamientoLEADING);

        FlowLayout PosicionamientoTRAILING = new FlowLayout(FlowLayout.TRAILING);
        PnlPal.setLayout(PosicionamientoTRAILING);

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelBorderLayout.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelBorderLayout2.java

 El BorderLayout situa y dimensiona los componentes en 5 regiones cardinales:
 - NORTE (BorderLayout.NORTH)
 - SUR (BorderLayout.SOUTH)
 - Occidente - OESTE (BorderLayout.WEST)
 - Oriente - ESTE (BorderLayout.EAST)
 - CENTER derecho (BorderLayout.CENTER)

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelGridLayout.java

 crea un componente matricial de n filas y n columnas

       // Crear n Botones; n=6
        Button[] Botones = new Button[6];
        for(int i=0;i<Botones.length; i++){
            Botones[i] = new Button("Botón: " + i);
        }

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelGridLayout2.java

        // Crear n Botones; n=6 y Asigna los Botones al Frame
        Button[] Botones = new Button[6];
        for(int i=0;i<Botones.length; i++){
            MyFrame.add(new Button("Botón" + i));
        }

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelGridLayout3.java

       ETIQUETAS, CAMPOS Y ÁREAS DE TEXTO

    AWT: Abstract Window Toolkit proporciona los componentes básicos de I/O. 
    Proporciona entre otras:
    la clase Window.
    la clase Frame derivada de Window.

    Jerarquía:
                                   ----------
                                   | Object |                                   java.lang
                                   ----------
                                       |            --------------------
                                 -------------                          |
                    -------------| Component |                          |
                    |            -------------                          |
                    |         _________|__________                      |
                    |        |                    |                     |
                    |   ----------          -------------               |
                    |---| Button |          | Container |               |
                    |   ----------          -------------               |
                    |  ---------             ______|_____               |
                    |--| Label |            |            |              |--------java.awt
                    |  ---------        ---------    ----------         |
              -----------------         | Panel |    | Window |         |
              | TextComponent |         ---------    ----------         |
              -----------------                          |              |
                ______|_____                             |              |
               |            |                            |              |
         ------------- ------------                  ---------          |
         | TextField | | TextArea |                  | Frame |          |
         ------------- ------------                  ---------          |
                                                         |---------------
                                                     ---------
                                                     | JFrame |               javax.swing
                                                     ---------


_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassLabel.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassLabel2.java

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassTextField.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassTextField2.java

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassTextArea.java

Font son clases que heredan de forma direta de Object.

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFont.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFontColor.java


CAJAS DE VERIFICACION, BOTONOES DE RADIO Y LISTAS

Checkbox, CheckboxGroup, List, Choice

    Jerarquía:
                                   ----------
                                   | Object |                                                   java.lang             
                                   ----------
                                       |                                      ------------- 
            --------             -------------             -----------------              |
            | Font |-------------| Component |-------------| CheckboxGroup |              |     
            --------             -------------             -----------------              |
                                       |                                                  |-----java.awt
         ---------- --------- ----------------- ------------ -------- ----------          |
         | Button | | Label | | TextComponent | | Checkbox | | List | | Choice |          |
         ---------- --------- ----------------- ------------ -------- ----------          |
                                ______|_____                                              |
                               |            |                                             |
                         ------------- ------------                                       |
                         | TextField | | TextArea |                           -------------
                         ------------- ------------                                       

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassCheckbox.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassCheckboxGroup.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassCheckboxGroupFontColor.java

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassList.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassListMultiple.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassListChoiceDesplegable.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassListChoiceDesplegable2.java

                            --------------
                            | Formulario |
                        --------------------------------
                        |    PnlFormulario             |           
                        |    PnlDatosPersonales        |          
                        |    PnlEstadoCivil            |          
                        |    PnlCiudades               |          
                        --------------------------------
                        | DatosPersonales(Panel)       |          
                        | EstadoCivil(Panel)           |          
                        | Ciudades(Panel)              |          
                        --------------------------------
                        | Main                         |     
                        --------------------------------     

_JavaDevelopment/testjdk_1.8.0_292/src/Formulario.java

Implementación en varias clases

 -----------------------------     -------------------------      -----------------------
 | FormularioDatosPersonales |     | FormularioEstadoCivil |      | FormularioProvincia |
 -----------------------------     -------------------------      -----------------------
        |      |                        ______|_____                    |     |
        |      |                       |            |                   |     |
        |      |            ------------------ ------------------       |     |
        |      -------------| FormularioMain | | FormularioMain |--------     |
        |                   ------------------ ------------------             |
        |                           |                   |                     |
        |                           |                   |                     |
        |                           --------------------|----------------------
        |                                               |
        -------------------------------------------------

    Con mis constructores... (un poco regular definidos.. review)
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioMain.java
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioCiudades.java
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioDatosPersonales.java
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioEstadoCivil.java
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioMain2.java

             -------------------
-------------| Formulario2Main |---------------------------------------------------------------------------
|            -------------------                                                                          |
|                                       ---------------                                                   |
|                          -------------|             |                                                   |
|                          |     I      ---------------                                                   |
|                      --------                                                                           |
|   MiFrame            |      |                                                                           |
|                      --------                                                                           |
|                                       ---------------                                                   |
|                          -------------|             |                                                   |
|                          |     I      ---------------                                                   |
|                      --------                                                                           |
|   Formulario         |      |                                                                           |
|                      --------                                                                           |
|                                                                                                         |
|                                                ------------------------------                           |
|                                   -------------| Formulario2DatosPersonales |----------                 |
|                                   |             ------------------------------        |                 |
|                                   |     I           |      ----------------           |                 |
|                      --------     |                 |      |              |           |                 |
|   DatosPersonales    |      | -----------------------      ----------------           |                 |
|                      --------     | PnlDatosPersonales          |     ---------------------------       |       
|                                   |                             ---->>| getPnlDatosPersonales() |--->>  |
|                                   |                                   ---------------------------       |       
|                                   |                                                   |                 |
|                                   -----------------------------------------------------                 |
|                                                ------------------------------                           |
|                                   -------------| Formulario2EstadoCivil     |----------                 |
|                                   |             ------------------------------        |                 |
|                                   |     I           |      ----------------           |                 |
|                      --------     | PnlEstadoCivil  |      |              |           |                 |
|   EstadoCivil        |      | -----------------------      ----------------           |                 |
|                      --------     |                             |     ---------------------------       |       
|                                   |                             ---->>| getPnlEstadoCivil()     |--->>  |
|                                   |                                   ---------------------------       |       
|                                   |                                                   |                 |
|                                   -----------------------------------------------------                 |
|                                                ------------------------------                           |
|                                   -------------| Formulario2Ciudades        |----------                 |
|                                   |             ------------------------------        |                 |
|                                   |     I           |      ----------------           |                 |
|                      --------     | PnlCiudades     |      |              |           |                 |
|   Ciudades           |      | -----------------------      ----------------           |                 |
|                      --------     |                             |     ---------------------------       |       
|                                   |                             ---->>| getPnlCiudades()        |--->>  |
|                                   |                                   ---------------------------       |       
|                                   |                                                   |                 |
|                                   -----------------------------------------------------                 |
|                                                                                                         |
-----------------------------------------------------------------------------------------------------------

_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2Main.java
_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2Ciudades.java
_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2DatosPersonales.java
_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2EstadoCivil.java

Otra forma de organizar (modificando los paneles.. ) y utilizando las mismas clases predefinidas
_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2Main2.java

DIALOGOS Y MENUS

Clases
Dialog y FileDialog
MenuBar y Menu

  Jerarquía:
                                   ----------
                                   | Object |                                   java.lang
                                   ----------
                                       |            --------------------
                              _________|__________                      |
                             |                    |                     |
                   -----------------        -------------               |
                   | MenuComponent |--------| Component |               |
                   -----------------        -------------               |
                  _________|__________            |                     |
                 |                    |           |                     |
           ------------          ------------     |                     |
           | MenuItem |          | MenuBar  |     |                     |
           ------------          ------------     |                     |
                 |                                |                     |
            -----------                     -------------               |
            |  Menu   |                     | Container |               |
            -----------                     -------------               |
                                             ______|_____               |
                                            |            |              |--------java.awt
                                        ---------    ----------         |
                                        | Panel |    | Window |         |
                                        ---------    ----------         |
                                                         |              |
                                                     ----------         |
                                                     | Dialog |         |
                                                     ----------         |
                                                         |              |
                                                  --------------        |
                                                  | FileDialog |        |
                                                  --------------        |

Dialog, ventana para recoger información del usuario; su disposición por defecto es BorderLayout. 
Propietario de dialogo frame ó diálogo
Modales ó
No Modales (default) - Bloquean las demás ventanas de la aplicación (salvo las que se hayan cerrado por el propio dialogo)

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassDialog.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassDialog2.java

Dialogo de carga / almacenamiento de ficheros (FileDialog), clase especializada de Dialog, gestiona la selecciín de un fichero entre los sistemas de ficheros accesibles.
Los dialogos de ficheros son modales y sus propietarios deben ser Frames.

Cargar Load
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFileDialog2.java
Guardar Save
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFileDialog.java

MenuBar se usa para dotar de una barra principal de menú a un frame.
sólo tiene el constructor sin argumentos.
setMenuBar es un método de Frame para adicionar un menú a un frame.
Una vez que disponemos de un objeto barra de menú, añadimos menús (add), 

_JavaDevelopment/testjdk_1.8.0_292/src/MenuBarMenu.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassMenuBarMenu.java

EVENTOS

Java proporciona mecanismos adecuados para tratar situaciones que habitualmente se producen de manera asíncrona a la ejecución del programa, producidas desde el exterior de la aplicación.
Más comunes en la ejecución de una app que proporciona una GUI son:
- Pulsación de ratón, se situa en un componente gráfico, , sale de un componente gráfico
- Pulsación de una tecla
- Se cierra una ventana... etc

- usuario interactua con la app por medio de dispositivos de I/O. teclado, ratón, etc.
- los dispositivos de I/O generan señales eléctrica que son recogidas por los controladores (placas, puertos, etc).
- los drivers(manejadores), de cada dispositivo recogen las señales eléctricas, las codifican y traspasan ea la CP. activan pines de interrupción excepción de la CPU.
- La CPU habitualmente deja de ejecutar la acción en curso(salvo que esta acción tenga mayor prioridad que la asociada a la interuupción que le llega) y ejecuta la rutina de tratamiento que le asigna el SO.
- El SO determina si tiene que tratar la o si tiene que pasarla a alguna aplicación que se ejecuta sobre él. En este caso a la JVM.
- La JVM determina el componente sobre el que se produce la interrupción y consulta si se ha definido alguna acción. si no hay nada definido, la CPU continua con la accion que estaba antes de la interrupción.
- Si se ha definido: 
- la JVM crea un objeto evento con la información de la acción, 
- se pasa el evento a la clase que tratara la interrupción
- se pasa el flujo de control(de ejecución) a la clase Java que hemos creado para tratar la interrupción
- se pasa el flujo de control a la CPU para que continúe con la acción que estaba antes de la interrupción

La JVM recoge la información de la interrupción del SO , determina la ventana y el componente, donde se ha producido el evento y ejecuta la acción asociada al tipo de evento que llega.

Por lo tanto: 

1. necesitamos clases que definan las posibles acciones a realizar cuando llegan los diferentes tipos de eventos.
2. No es necesario definir acciones para todos los eventos ni para todos los objetos.
3. necesitamos un mecanismo para asociar acciones a los distintos eventos que se puedan producir sonbre cada componente de nuestra GUI.

Java proporciona una serie de Interfaces que agrupan métodos relacionados para el tratamiento de eventos.
Los interfaces más comunes, normalmente relacionados con GUI's basados en AWT se encuentran en el paquete java.awt.event

El mecanismo básico de eventos de Java se basa en lla existencia de las clases de eventos y los interfases "listeners", son interfaces que debemos implementar, colocando las acciones deseadas en sus métodos, también podemos basarnos en las implementaciones con métodos vacios que proporciona el SDK (adaptadores).
AWT proporciona una ámplia gama de eventos que pueden ser recogidos por los métodos existentes en las implementaciones que hagamos de los listeners.

Ex: Eventos, Interfaces y adaptadores más utilizados en app de catácter general.

            Eventos                    Interfaces                 Adaptadores
            ----------              ---------------             
 --------- | AWTEvent | ---------- | EventListener |            java.awt.event
|           ----------              ---------------             
|                                   ---------------              --------------
|           ----------       ______| MouseListener | ---------- | MouseAdapter |
|          | Mouse    |_____|       ---------------              --------------
|          |   Event  |     |______ ---------------------        -------------------
|           ----------             | MouseMotionListener | ---- | MouseMotinAdapter |
|                                   ---------------------        -------------------
|           ----------              ---------------              --------------
|--------- | KeyEvent | ---------- | Key  Listener | ---------- | Key  Adapter |
|           ----------              ---------------              --------------
|           -------------           ----------------             ---------------
|--------- | WindowEvent |-------- | WindowListener | ----------| WindowAdapter |
|           -------------           ----------------             ---------------
|           -------------           ----------------
|--------- | ActionEvent | --------| ActionListener |
|           -------------           ----------------
|           -----------             --------------
 --------- | ItemEvent | ----------| ItemListener |
            -----------             --------------

Ex: MouseListener
https://docs.oracle.com/javase/8/docs/api/java/awt/event/MouseListener.html
y KeyListener
https://docs.oracle.com/javase/7/docs/api/java/awt/event/KeyListener.html

tiene los siguientes métodos:


void 	mousePressed(MouseEvent e)  -> Se invoca cuando el botón del ratón ha sido pulsado en un componente.
void 	mouseReleased(MouseEvent e) -> Se invoca en la acción contraria

void 	mouseClicked(MouseEvent e)  -> Se invoca cuando se han producido las dos acciones consecutivas (pulsar y soltar).

void 	mouseEntered(MouseEvent e)  -> Se invoca al entrar de un componente con el puntero del ratón - focus
void 	mouseExited(MouseEvent e)   -> Se invoca al salir  de un componente con el puntero del ratón - blur

Si queremos que un texto se ponga de color rojo al situarnos sobre él componente y de color azul al salir del mismo.
Crearemos una clase que implemente los métodos mouseEntered y mouseExited respectivamente; con el interface MouseListener el compilador puede detectar errores de tipo sintactico mientras que extendiendo el MouseAdapter aunque es más comodo, es menos seguro, y el compilador no detectara errores sintactacticos al definir un método.

Los objetos de tipo evento, ex: MouseEvent, nos permiten consultar información relativa a la interrupción que genera el evento.
nos permite conocer información que proviene del SO y de la JVM.
MouseEvent
https://docs.oracle.com/javase/8/docs/api/java/awt/event/MouseEvent.html
y KeyEvent
https://docs.oracle.com/javase/7/docs/api/java/awt/event/KeyEvent.html


Nos proporciona entre otra info: el botón que se ha pulsado, las coordenadas X e Y en pix en las que se encontraba el puntero del ratón respecto al componente que ha generado la interrupción(el evento), el componente que ha generado la interrupción, etc.

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerMouse.java

Podemos implementar tantas clases "listeners" como comportamientos diferentes deseemos y asignar diferentes componentes a distintos listeners.

Un componente no tiene por que estar limitado a la funcionalidad de un sólo listener, por ejemplo pordemos hacer que un componentes se pueda seleccionar con ratón(MouseListener) o con teclado(KeyListener)

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerKey.java

Esta clase prueba las dos clases ListenerMouse.java y ListenerKey.java

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerMouseKey.java

Eventos "más usados" del raton:
----------------------------------------------------------------------------
| INTERFACE              | Adaptadores               | Evento              |
----------------------------------------------------------------------------
| MouseListener          | MouseAdapter              | MouseEvent          |
----------------------------------------------------------------------------
| métodos                |                           | métodos             |
| mouseClicked           |                           | int getClickCount() |
| mouseEntered           |                           | Point getPoint()    |
| mouseExited            |                           | int getX()          |
| mousePressed           |                           | int getY()          |
| mouseReleased          |                           | Object getSource()  |
|                        |                           | int getButton()     |
----------------------------------------------------------------------------
| MouseMotionListener    | MouseMotionAdapter        | MouseEvent          |
----------------------------------------------------------------------------
| métodos                |                           | métodos             |
| mouseDragged           |                           | int getClickCount() |
| mouseMoved             |                           | Point getPoint()    |
|                        |                           | int getX()          |
|                        |                           | int getY()          |
|                        |                           | Object getSource()  |
|                        |                           | int getButton()     |
----------------------------------------------------------------------------
| MouseWheelListener     | No tiene adaptador        | MouseWheelEvent     |
----------------------------------------------------------------------------
| métodos                |                           |                     |
| mouseWheel             |                           |                     |
----------------------------------------------------------------------------

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouse.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouse.java

La clase _JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouse.java puede ser utilizada por otras app
En este caso sobre un panel:
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouse2.java

La clase _JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouseObject.java
Utiliza algunos métodos de MouseEvent
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouseObject.java

Java proporciona el adaptador MouseAdapter, que implementa todos los métodos del interfaz MouseListener de esta manera, 
si usamos MouseAdapter, podemos sobrecargar únicamente los métodos que deseemos.
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouseAdapter.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouseAdapter.java
cuando ejecutamos la clase con este método: public void mouseEited(MouseEvent e){
no se ejecuta evento Exited del Mouse ya que el compilador no detecta el error sintactico
cuando ejecutamos la clase con este método: public void mouseExited(MouseEvent e){
se ejecuta el evento mouseExited.

Ex: en Estas clases: 
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouseAdapter2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouseAdapter2.java
Se extiende de MouseAdapter, 
se crea un constructor a través del cual se puede indicar una etiqueta donde los métodos de la clase podrán asignar diferentes textos.
La etiqueta no debería ser visible en la clase ListenerEventosMouseAdapter2.java. 
Deberá unirse en un sólo fichero ambas clases, (aunque es menos modular y reutilizable)
Java proporciona medios de mayor complejidad para establecer una solución más elegante a esta interacción GUI/Adaptador aunque no se usan mucho.

Los eventos de movimiento de ratón. (mouseMoved, mouseDragged)
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerMouseMotion.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerMouseMotion.java

Se crea un constructor que contiene como parámetros dos etiquetas
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerMouseMotion2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerMouseMotion2.java

Si queremos evitar el constructor con parámetros unificar el GUI y el adaptador en un sólo fichero
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouseMotion.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaEventosMouseMotion.java


EVENTOS DE TECLADO Y DE VENTANA

----------------------------------------------------------------------------
| INTERFACE              | Adaptadores               | Evento              |
----------------------------------------------------------------------------
| KeyListener            | KeyAdapter                | KeyEvent            |
| métodos                |                           | métodos             |
| keyPressed             |                           | char getKeyChar()   |
| keyReleased            |                           | int getKeyCode()    |
| keyTyped               |                           | String getKeyText() |
|                        |                           | Object getSource()  |
----------------------------------------------------------------------------
| WindowListener         | WindowAdapter             | WindowEvent         |
| métodos                |                           | métodos             |
| windowActivated        |                           | getWindow()         |
| windowDeactivated      |                           | getOppositeWindow() |
| windowOpened           |                           | getNewState()       |
| windowClosing          |                           | getOldState()       |
| windowClosed           |                           | getSource()         |
| windowIconified        |                           |                     |
| windowDeiconified      |                           |                     |
----------------------------------------------------------------------------

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosKey.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosKey.java

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosKeyAdapter.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosKeyAdapter.java

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerWindow.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerWindow.java

EVENTOS DE ACCIÓN, ENFOQUE Y ELEMENTO
Estos eventos tienne un nivel de abstraccción superior a los de ratón y teclado; en estos tres casos el evento se produce cuando ocurre 
una acción sobre un componente, independientemente de la causa fisica que produce ese evento.
ex: pulsar un botón haciendo uso del ratón, del teclado, e incluso por programa.
El interfaz actionlistener proporciona un método que se activa con independencia de la causa física ó lǵica que activa el componente.

------------------------------------------------------------------------------
| INTERFACE              | Adaptadores               | Evento                |
------------------------------------------------------------------------------
| ActionListener         |                           | ActionEvent           |
| métodos                |                           | métodos               |
| actionPerformed        |                           | getActionCommand()    |
|                        |                           | getWhen()             |
|                        |                           | getSource()           |
------------------------------------------------------------------------------
| FocusListener          | FocusAdapter              | FocusEvent            |
| métodos                |                           | métodos               |
| focusGained            |                           | getOppositeComponent()|
| focusLost              |                           | getID()               |
|                        |                           | getSource()           |
------------------------------------------------------------------------------
| ItemListener           |                           | ItemEvent             |
| métodos                |                           | métodos               |
| itemStateChanged       |                           | getStateChange()      |
|                        |                           | getItem()             |
|                        |                           | getItemSelectable()   |
|                        |                           | getSource()           |
------------------------------------------------------------------------------

Eventos de ACCIÓN
ActionListener y ActionEvent

Tratamiento de eventos de acción
Escribe por consola información del evento cada vez que se activa actionPerformed (método de ActionListener)

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerAction.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerAction.java

    //Constructor que recibe un panel como parámetro - Cambia el color del panel
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerAction2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerAction2.java

Eventos de ENFOQUE - focusGained - focusLost
FocusListener, FocusEvent, FocusAdapter

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerFocus.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerFocus.java

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerFocusAdapter.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerFocusAdapter.java


Eventos de ELEMENTO - itemStateChanged - cambio de estado 
ItemListener e ItemEvent

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerItem.java
        // getStateChange - newState: 1 => Seleccionado
        // getStateChange - newState: 2 => No Seleccionado

        // getState - bState: true => Seleccionado
        // getState - bState: false => No Seleccionado

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerItem.java


Opciones y validaciones interactiva, Checkbox, List(lista), Choice (lista desplegable)
// constructor que recoge un vector de componentes con el fin de actuar sobre los mismos.
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerItem2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerItem2.java

Calculadora
Implementar una app que ofrezca el interfaz y el comportamiento de una calculadora sencilla.

Nuestra calculadora contendrá:
10 dígitos 0-9, 
punto decimal(.), 
signo igual (=), 
operadores (+, -, *, /,) 
espacio para visualizar las pulsaciones del usuario y los resultados obtenidos

Interfaz GUI:
---------------------------
|  _____________________  |
| |                     | |
| |_____________________| |
---------------------------
| ----- ----- ----- ----- |
| | 0 | | 1 | | 2 | | + | |     -> 0*3+0;   0*3+1;    0*3+2;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 3 | | 4 | | 5 | | - | |     -> 1*3+0;   1*3+1;    1*3+2;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 6 | | 7 | | 8 | | * | |     -> 2*3+0;   2*3+1;    2*3+2;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 9 | | . | | = | | / | |     ->     9;       .;        =;
| ----- ----- ----- ----- |
---------------------------
El comportamiento será:

--------------      --------------      --------------      --------------      -------------
| Introducir |--->> | Introducir |--->> | Introducir |--->> | Introducir |--->> |  Obtener  |
| Operando 1 |      |  OPERADOR  |      | Operando 2 |      |    SIGNO   |      | Resultado |
--------------      --------------      --------------      --------------      -------------
                           ^                                                           |
                           |___________________________________________________________|

5 * 3 = 15 / 3 = 5 * 2 = 10

Los operandos podrán ser valores númericos enteros o decimales con signo.

Un operando:

                     -----
                -----| - |----
                |    -----   |
Operando -------|            |
                |    ----------         -----      ----------
                -----| Digito |---------| . |------| Digito |
                     ----------         -----      ----------
                      |____| |                      |____| |
                             |                             |                                
                             -----------------------------------------

Diseñada según principios básicos de la PPO.
Botones con diferentes colores
Compotamiento para todos los botones:
// tanto con el ratón como con el teclado:
focusGained --> cambia de color
focusLost -->  color original.
Al pulsar una opción no valida (ex: dígito después del igual, dos operadores seguidos, etc), debe mostrar una indicación de error en el área de resultados y el botón pulsado de color rojo.


Definición de Interfaz gráfico:  - MVC - ModeloVC
Dígitos: Panel con botones que representan los dígitos del 0-9, signo(.), signo(=)
Operadores: Panel con cuatro botones de signos (+, -, *, /)
Resultados: Visor de la calculadora

Utilizando las clases: Dígitos, Operadores y Resultados, podemos definir diferentes representaciones de calculadoras.

            -------------------
            | GUICalculadora2 |             GUICalculadora?, necesitan tener acceso a los botones individuales
            -------------------
             |       |       |
         -------------------------
         |    GUICalculadora1    |
         -------------------------
             |       |        |
             | -------------- |
             | | Operadores | |             Operadores, botones individuales (+,-,*,/)
             | -------------- |
         -----------          |
         | Digitos |          |             Digitos, botones individuales (0-9,.,=)
         -----------          |
                         --------------
                         | Resultados |     Visor de la calculadora
                         --------------

    GUICalculadora?, necesitan tener acceso a los botones individuales, 
    que se definen en Digitos y Operadores, 
    de esta manera se podrá asignar diferentes objetos de tratamiento de eventos a los botones.

    Digitos, proporciona su panel con la estructura de botones individuales (0-9,.,=)
    Operadores, proporciona su panel con la estructura de botones individuales (+,-,*,/)

    Para que los botones de cada panel presente el color deseado, se proporcionará un constructor que admite un parámetro de tipo Color.

    Resultados, proporciona un campo de texto deshabilitado que hará las veces de visor de la calculadora.

    Diseño de clases: - MVC - MVistaC

     -----------
   --| Digitos |-------------------
   | -----------                  |
   | // propiedades               |
   | Panel                        |
   | Button(12)                   |
   |                       métodos|
   |                        --------------
   |                        | getPanel() | -->
   |                        --------------
   |                              |
   |                        --------------
   |                        | getButton() | -->
   |                        --------------
   |                              |
   |                 Constructores|
   |                        ------------------
   |                        | Digitos(Color) | <--
   |                        ------------------
   |                              |
   |                        -------------
   |                        | Digitos() | <--
   |                        -------------
   |                              |
   --------------------------------

     --------------
   --| Operadores |----------------
   | --------------               |
   | // propiedades               |
   | Panel                        |
   | Button( 4)                   |
   |                       métodos|
   |                        --------------
   |                        | getPanel() | -->
   |                        --------------
   |                              |
   |                        --------------
   |                        | getButton() | -->
   |                        --------------
   |                              |
   |                 Constructores|
   |                        ---------------------
   |                        | Operadores(Color) | <--
   |                        ---------------------
   |                              |
   |                        ----------------
   |                        | Operadores() | <--
   |                        ----------------
   |                              |
   --------------------------------

     --------------
   --| Resultados |----------------
   | --------------               |
   | // propiedades               |
   | Panel                        |
   | TextField                    |
   |                       métodos|
   |                        --------------
   |                        | getPanel() | -->
   |                        --------------
   |                              |
   |                        ------------------
   |                        | getTextField() | -->
   |                        ------------------
   |                              |
   |                 Constructores|
   |                        ---------------------
   |                        | Resultados(Color) | <--
   |                        ---------------------
   |                              |
   |                        ----------------
   |                        | Resultados() | <--
   |                        ----------------
   |                              |
   --------------------------------
   Implementación del interfaz gráfico de usuario

   _JavaDevelopment/testjdk_1.8.0_292/src/Digitos.java
   _JavaDevelopment/testjdk_1.8.0_292/src/PruebaDigitos.java

   _JavaDevelopment/testjdk_1.8.0_292/src/Operadores.java
   _JavaDevelopment/testjdk_1.8.0_292/src/PruebaOperadores.java

   _JavaDevelopment/testjdk_1.8.0_292/src/PruebaResultados.java
   _JavaDevelopment/testjdk_1.8.0_292/src/Resultados.java

    Clase que implementa la interfaz de la calculadora
    _JavaDevelopment/testjdk_1.8.0_292/src/GUICalculadora1.java
    Clase que ejecuta la interfaz GUI de la calculadora1
    _JavaDevelopment/testjdk_1.8.0_292/src/Calculadora1.java

    Sé puede crear otra apariencia de Calculadora:

    Clase que implementa la interfaz de la calculadora
    _JavaDevelopment/testjdk_1.8.0_292/src/GUICalculadora2.java
    Clase que ejecuta la interfaz GUI de la calculadora2
    _JavaDevelopment/testjdk_1.8.0_292/src/Calculadora2.java

    Diseño del Tratamiento de Eventos

    Eventos de ventana --> windowClosing
    Eventos de enfoque --> focusGained y focusLost cuando nos situemos en los botones con el teclado

    -----------------------
    |   GUICalculadora1   |
    ----------------------...............
                     |  ControlFoco     |
                     .......................
                        |  ControlVentana  |
                        ........................
                            |  ControlRaton    |
                            ....................
                                    ^
                                    |
                              OpcionErronea

     ------------------
   --| ControlVentana |------------
   | ------------------           |
   |                       métodos|
   |                        -----------------------------
   |                        | windowClosing(windowEvent)| -->
   |                        -----------------------------
   |                              |
   --------------------------------

     ------------------
   --| ControlFoco    |------------
   | ------------------           |
   | // propiedades               |
   | Color   ^                    |
   |   |     |                    |
   |   |     |              ---------------------
   |   |     <--------------| ControlFoco(Color)| <--
   |   |                    ---------------------
   |   |                   métodos|
   |   |                    --------------------------
   |   |                    | focusGained(focusEvent)| -->
   |   |                    --------------------------
   |   |                          |
   |   |                    ------------------------
   |   -------------------->| focusLost(focusEvent)| -->
   |                        ------------------------
   |                              |
   --------------------------------

    Eventos de ratón 
    Constructor que permite indicar el color del fondo de los botones y el campo de texto del los resultados.

     ------------------
   --| ControlRaton   |------------
   | ------------------           |
   | // propiedades               |
   | TextField                    |
   | Color   ^                    |
   |   |     |                    |
   |   |     |              ---------------------------------
   |   |     <--------------| ControlRaton(TextField, Color)| <--
   |   |                    ---------------------------------
   |   |                   métodos|
   |   |                    ---------------------------
   |   |                    | mouseEntered(mouseEvent)| -->
   |   |                    ---------------------------
   |   |                          |
   |   |                    -------------------------
   |   -------------------->|mouseExited(mouseEvent)| -->
   |                        -------------------------
   |                              |
   |                        ---------------------------
   |                        | mouseClicked(mouseEvent)| -->
   |                        ---------------------------
   |                              |        ^
   --------------------------------        |
                                      OpcionErronea

_JavaDevelopment/testjdk_1.8.0_292/src/ControlVentana.java
_JavaDevelopment/testjdk_1.8.0_292/src/ControlFoco.java
_JavaDevelopment/testjdk_1.8.0_292/src/ControlRaton.java

DISEÑO DEL CONTROL  - MVC - MVControlador - lógica I/O
Pulsaciones del usuario => Input
Resultados => Output

ControlRaton, recoge las pulsaciones que realiza el usuario, (los eventos). 
Procesamiento, realizará el tratamiento de los eventos

ControlRaton le pasará en forma de caracteres("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "=", ".", "+", "-", "*", "/"), para ProcesaEvento.

En caso de que el usuario pulse una opción inadecuada, "ProcesaEvento", generara una Exception.

                --------------------
        --------|   ControlRaton   |
        |       --------------------
        |                ^
        |                |
-----------------        |
| ProcesaEvento |--------|
-----------------        |
                         | 
                --------------------
                |   OpcionErronea  |
                --------------------

El esquema de clases de la app:


         -------------------------
         |    GUICalculadora1    |
         ----------------------------------------------...............
             |       |        |            |        |  ControlFoco     |
             |       |        |            |        .......................
             |       |        |            |           |  ControlVentana  |
             |       |        |            |           .........................
             |       |        |            |  --------------|  ControlRaton    |
             |       |        |            |  |             ....................
             |       |        |            |  |                     ^
             |       |        |            |  |                     |
             |       |        |     -----------------       -----------------
             |       |        |     | ProcesaEvento |       | OpcionErronea |                               
             |       |        |     -----------------       -----------------                          
             | -------------- |                                                                        
             | | Operadores | |                                                                                     
             | -------------- |                                                                        
         -----------          |                                                                        
         | Digitos |          |                                                                                     
         -----------          |                                                                        
                         --------------                                                                        
                         | Resultados |                                                                             
                         --------------                                                                        


--------------      --------------      --------------      --------------      -------------
| Introducir |--->> | Introducir |--->> | Introducir |--->> | Introducir |--->> |  Obtener  |
| Operando 1 |      |  OPERADOR  |      | Operando 2 |      |    SIGNO   |      | Resultado |
--------------      --------------      --------------      --------------      -------------
                           ^                                                           |
                           |___________________________________________________________|

                     -----
                -----| - |----
                |    -----   |
Operando -------|            |
                |    ----------         -----      ----------
                -----| Digito |---------| . |------| Digito |
                     ----------         -----      ----------
                      |____| |                      |____| |
                             |                             |                                
                             ------------------------------------------

ProcesaEvento, implementará el control de la calculadora.
Cajas --> representan los diferentes estados en los que nos podemos encontrar y
Flechas --> son las transiciones permitidas desde cada uno de esos estados

                          -----
                     ---->| - |----
-----------------    |    -----   |
| ProcesaEvento |----|            |
-----------------    |    ----------     -----     ----------
                     ---->| Digito |---->| . |---->| Digito |
                          ----------     -----     ----------
                           ^____| |                 ^____| |
                                  |                        |                                
                                  --------------------------
                                  |
                                  v               -----
                            --------------   ---->| - |----
                            | Introducir |   |    -----   |
                            |  OPERADOR  |---|            |
                            --------------   |    ----------     -----     ----------
                                   ^         ---->| Digito |---->| . |---->| Digito |
                                   |              ----------     -----     ----------
                                   |               ^____| |                 ^____| |
                                   |                      |                        |      -----                     
                                   |                      ------------------------------->| = |
                                   |                                                      -----
                                   |                                                        |
                                   ----------------------------------------------------------

Podemos ver como el usuario va evolucionando según la pulsación de los botones, y podemos conocer las pulsaciones permitidas:
Diagrama de estados:

                          -----      1
                     ---->| - |----
-----------------    |    -----   |
| ProcesaEvento |----|            |  2          3              4
-----------------    |    ----------     -----     ----------
                     ---->| Digito |---->| . |---->| Digito |
                          ----------     -----     ----------
                           ^____| |                 ^____| |
                                  |                        |                                
                                  --------------------------
                                  |
                                  v        5      -----      6
                            --------------   ---->| - |----
                            | Introducir |   |    -----   |
                            |  OPERADOR  |---|            |  7          8              9
                            --------------   |    ----------     -----     ----------
                                   ^         ---->| Digito |---->| . |---->| Digito |
                                   |              ----------     -----     ----------
                                   |               ^____| |                 ^____| |
                                   |                      |                        |      -----   10
                                   |                      ------------------------------->| = |
                                   |                                                      -----
                                   |                                                        |
                                   ----------------------------------------------------------

    Estado 5: hemos recibido ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9" y un operador "+", "-", "*", "/")
    Estado 7: sólo se permite pulsar (".", "=", ó "0", "1", "2", "3", "4", "5", "6", "7", "8", "9")


    ProcesaEvento
    Se definen las propiedades static para evitar pasar la referencia de la instancia de la clase ProcesaEvento a la clase ControlRaton.

    Sin embargo, si en una misma aplicación se quiere crear más de una calculadora, ProcesaEvento no funcionaría ya que todas las calculadoras de la aplicación compartirían las mismas propiedades de estado.

    Si cada calculadora se encontrara en una app separada ProcesaEvento si funciona, ya que cada calculadora se ejecuta sobre una JVM diferente.
    
    Para evitar las propiedades static: 
    - pasar la referencia del objeto ProcesaEvento a la clase ControlRaton.
    - utilizar la referencia pasada en lugar del nombre de la clase cuando la invoca en el try (ProcesaEvento.charPulsado())

_JavaDevelopment/testjdk_1.8.0_292/src/ProcesaEvento.java
_JavaDevelopment/testjdk_1.8.0_292/src/OpcionErronea.java







GENERALES:
----------
CLASSPATH, indica donde se encuentran los objeto (*.class) y la instalación la actualiza.
La variable de entorno CLASSPATH se especifica de manera diferente según cual sea el SO que utilizamos.
Los ubicación de los ejecutables del SDK por defecto, depende de la version del SDK y pueden instalarse en cualquier lugar.
La ayuda del SDK, se accede a través del index.html, contiene un enlace importante referente al API, proporciona información sobre los métodos y clases disponibles.
Los programas en Java No deben incluir números de línea
La estructura mínima de un programa Java como mínimo: 
- Debe definirse una clase,
- Debe definirse un método main,
- Debe utilizarse un parámetro String[], aunque no se use.
En un programa Java se debe tener en cuenta:
- Las estructuras (clases, métodos) se delimitan con {llaves de comienzo y final}
- El caracter ';', sirve para separar instrucciones
- Una clase declarada como pública es accesible a cualquier otra clase.
El fuente, (código) de un programa se debe grabar con formato de texto ASCII, y extensión java
Los errores de compilación pueden ser por:
- errores en el código
- el fichero esta guardado en un formato inadecuado y/o con extensión inadecuada (debe ser java)
- para compilar con con javac: javac nombredelfichero.java
Los nombres de las variables NO deben contener espacios en blanco, y pueden empezar por una [A-Z, a-z], "$", ó "_"
Los tipos de datos permiten que el traductor realice comprobaciones estáticas respecto a la corrección del programa y permiten clasificar a las variables según su naturaleza.
Ex:    
   short Short = 12826;
   long Long = 26;
   float $Float = 12.6f;
   boolean Boolean = true;
   char Char = 'S';
   short SegundoShort = (short) (200+112); 
For es adecuando cuando conocemos a priori el número de iteraciones
For obliga a evaluar la condición de finalización al comienzo del bucle
While es adecuado cuando no conocemos a priori el número de iteraciones
While Tiene dos variantes: una en la que se evalúa la condición de finalización, al comienzo del bucle y otra al final del mismo
if Permite cualquier número de operaciones y permite expresiones con operadores de comparación y operadores lógicos
Es más eficiente una solución con if anidados 
Los if anidados no tienen límite fijado por el lenguaje
En un Switch se puede definir un número ilimitado de ramas basadas en una misma condición
Los 'case', definen los valores que se comparan con el resultado de la condición del switch
La instrucción switch se termina cuando el flujo de control llega a una clausula break ó a una clausula switch
switch puede contener una cláusula 'default'
switch puede devolver valores de tipo: short, int, char, byte
métodos: 
- permiten encapsular instrucciones, 
- pueden contener cualquier número y tipo de instrucciones, 
- pueden ser invocados desde diferentes lugares de una app.
- cuando se devuelve un valor se debe indicar el tipo antes del nombre
- cuando NO se devuelve un valor se debe indicar void antes del nombre
Ex:
si public float getPrecio(){};
puedo: float Precio = getPrecio(); if (getPrecio>200f)..
Los parámetros pertenecen al método y los argumentos al programa llamante y cada parámetro debe corresponder en tipo con su argumento
'return' debe ser la última instrucción de un método y puede presentarse sin argumento
cuando se devuelve un valor debe contener return;
??? cuando NO se devuelve un valor debe ó puede contener return;
Los argumentos basados en tipos primitivos (byte, short, int, long, char, float, double y boolean), de datos son pasados por valor
Los argumentos NO basados en tipos primitivos (byte, short, int, long, char, float, double y boolean), de datos son pasados por referencia
Los argumentos pasados por valor nunca quedan modificados después de la ejecución de los métodos
Los argumentos pasados por referencia pueden ser modificados en los métodos llamados.
El método sqrt de la clase Math devuelve un resultado de tipo double
Los String NO son tipos nativos de datos, y no funcionan igual que los tipo char, y se concatenan con "+".
Un String con valor null es diferente a un String con valor ""
equals compara dos Strings caracter a caracter
Si dos variables String apuntan a la misma estructura de datos, al compararlos con "==" or con "equals" el resultado es true
length devuelve la longitud el String
int[] x; int x[] producen el mismo resultado
float[]x = {1.1f, 2.2f, 3.3f}; float[] x = new float[3] definen una matriz de 3 elementos
x[2]=1.1f; float[] x = {1.1f, 2.2f}; float[] x={1.1f}; estan bien definidas
Las matrices pueden ser recorridas mediante bucles
Los argumentos de tipo Matriz se escriben SIN corchetes y los parámetros CON corchetes
Las clases pueden contener propiedades y métodos ó pueden contener sólo propiedades ó pueden contener sólo métodos
Las propiedades de una clase definen su estado
Las propiedades privadas de una clase son accesibles directemente desde el interior de la clase 
Los métodos publicos de una clase son accesibles desde el exterior de esa clase 
Las instancias de una misma clase NO comparten las propiedades de esa clase
No existe un límite definido al número de instancias de una clase que podemos crear
Se instancia con new y se usa notación punto para acceder a una propiedad o a un método de una instancia de clase.
Los métodos sobrecargados:
- Deben tener el mismo nombre y NO deben presentar la misma firma
La firma de un método se define por el nombre del método, el número y tipo de parametros atendiendo al orden de colocación.
Los constructores:
- nos permiten iniciliazar el estado de una clase en el momento de su instanciación, 
- admiten sobrecarga y deben denominarse igual que la clase que les contiene, 
- tienen implicito el atributo de acceso public y el atributo de retorno void.
clases como parámetros (class):
- podemos aplicar los métodos de una clase sobre las propiedades de diferentes instancias de otra clase.
- podemos pasar distintas instancias de una clase a los métodos (incluidos constructores) de otra clase.
Las propiedades de instancia de una clase:
- se crean cada vez que se define una instancia de la clase.
Las propiedades estáticas de clase de una clase:
- existen a partir de la definición de la clase
- son compartidas por todas las instancias de esa clase
- Se pueden referenciar a través del nombre de la clase
Los métodos de instancia se pueden referenciar a través del nombre de su clase.
Los métodos de clase se pueden referenciar a través del nombre de su clase y a través del nombre de una instancia de su clase.
Los métodos estáticos de clase solo pueden referenciar objetos estáticos.
Las propiedades estáticas de una clase nos permiten que distintas instancias de esa clase compartan sus valores.
Una clase puede contener simultaneamente objetos de clase y de instancia.
La sentencia 'package' de existir debe ser la primera de un fichero .java
Los miembros públicos de una clase son accesibles desde las clases situadas en otros paquetes.
Herencia sirve para crear subclases/clases derivadas que especializan los miembros (propiedades y métodos) de la super clase.
El método super(parámetros) invoca al constructor de la superclase que coincida en firma con la llamada.
Si se usa super, debe ser (obligatoriamente) la primera sentencia del constructor.
una clase sólo puede heredar de otra clase
Polimorfismo 
- se resuelve en tiempo de ejecución.
- permite invocar a métodos de diferentes subclases haciendo uso de una misma referencia
- el método polimórfico debe existir en las subclases y en la superclase
- la referencia a partir de la que se invoca al método polimórfico debe ser del tipo de la superclase
Las clases abstractas 
- contienen al menos un método abstracto
- pueden tener todos sus métodos abstractos
- facilitan el diseño y desarrollo orientado a objetos
- permiten implementar con elegancia el mecanismo de polimorfismo
- Una clase abstracta pertenece a una jerarquía de clases mientras que una interfaz no pertenece a una jerarquía de clases. 
Los métodos abstractos Se declaran(acabando con el símbolo ";") y no se definen
Las interfaces
- Sólo pueden contener constantes y métodos abstractos
- Pueden contener sólo constantes
- NO implementan interfaces
- NO extienden interfaces ni clases
- Puede extender multiples superinterfaces, es decir, lista separada por comas de todas las interfaces que la nueva interfaz va a extender
- especifica qué se debe hacer, pero no cómo hacerlo
Una clase puede implementar varias interfaces, pero sólo puede tener una clase ascendiente directa. 
Clases sin relación de herencia pueden implementar la misma interfaz.
No se puede crear una instancia de un interfaz
No se puede crear una instancia de una clase abstracta
Las excepciones permiten separar la lógica del programa de las instruciones de control de errores, se tratan haciendo uso de la clase Throwable y sus clases derivadas 
Existen excepciones que obligatoriamente deben ser tratadas y otras que no
Es más habitual tratar excepciones de tipo Exception que de tipo Error
Cada bloque try puede tener asociado varios bloques catch
El bloque finally de existir, siempre se ejecuta
Las excepciones pueden propagarse entre métodos
Las instrucciones throw nos permiten propagar excepiciones
Cuando se produce una excepción, puede que provoque la ejecución de dos bloques 'catch' del mismo tipo, estando los bloques 'catch' en diferentes métodos.
El orden de colocación de los bloques catch es importante
Las excepciones definidas por el programador cubren situaciones erróneas que tienen que ver con la naturaleza de las aplicaciones, pueden contener miembros (propiedades y métodos).
throw se utiliza para levantar excepciones por programa.
throws se emplea en la declaración de un método.
Object es la raiz de toda la jerarquia de clases
Con la clase window se obtienen ventanas sin bordes y sin posibilidad de incluir barras de MENUS
Frame es más especializada que la clase Window, tiene un constructor que admite el título de la ventana, permite incluir barra de menús, es necesario invocar el método setVisible, y setSize, podemos instanciar cuantos Frames como deseemos.
Es posible trabajar con varias ventanas simultaneas.
Los componentes son menos especializados que los contenedores
Los botones no son subclases de los contenedores
Los paneles son subclases de los contenedores
Los Layouts permiten colocar los componentes con diferentes disposiciones y se pueden asociar a los paneles
FlowLayout es el layout que se asigna por defecto a los paneles, admite alineamiento horizontal.
BorderLayout contiene 5 regiones cardinales.
GridLayout divide el espacio de manera matricial (en rejilla), admite 2 parámetros filas y columnas
La clase Container es subclase de Component, y superclase directa de Panel, los paneles son Container.
La clase Label permite que se les defina un alineamiento, pueden ser variadas en tiempo de ejecución, derivan directamente de la clase Component
Los campos TextField pueden instanciarse indicando un texto inicial, permiten definir el número de caracteres de edición
Las fuentes Font, permiten definir el tamaño de los textos , el tipo de letra de los componentes.
TextArea deriva de TextComponent, puede configurarse para incluir o no barras de desplazamiento.
Checkbox admite un constructor vacio, tiene asociada una etiqueta identificativa.
CheckboxGroup permiten agrupar un conjunto de Checkbox, la activación de un elemento implica la desactivación del otro, derivan de Object
List, permite selecciones multiples, selecciones de un único elemento, configurarse para visualizar un número determinado de elementos, (el resto si los hay, pueden ser accedidos mediante barras de desplazamiento).
Choice, proporciona el método add para añadir elementos.
Diseño de formularios, la solución implementada con varias clases permite reutilizar y añadir código con mayor facilidad, además esta mejor diseñada desde el punto de vista de POO.
Dialogos, deben estar asociados a un propietario (Frame o Dialog), pueden ser modales o no modales.
FileDialog sólo admite como propietario un Frame, permiten establecer un directorio inicial para buscar el fichero, pueden ser modales y no modales.
MenuBar, solo pueden situarse sobre objetos Frame, Sólo presentan el constructor vacio, permiten añadir menus.
Menu pueden ser añadidos a las barras de menús.
Eventos, provienen en general de las interrupciones de hardware, son visibles de manera automática sin necesidad de invocar a ningún método, se tratan haciendo uso de los adaptadores xxxAdapter
Algunos interfaces xxxListener tienen asociada una clase xxxAdapter, y todos los interfaces xxxListener reciben un evento xxxEvent.
JVM interviene en el mecanismo de tratamiento de eventos, los eventos son objetos que crea la JVM.
Los métodos de tratamiento de eventos se encuentran en los interfaces xxxListener.
Los componentes AWT de una aplicación pueden tener asociado uno o más de un listener o adapter.
La asociación entre un componente y sus adaptadores se define mediante los métodos addxxxListener
Los eventos de ratón y movimiento de ratón utilizan los objetos de evento MouseEvent y MouseWheelEvent
El interfaz MouseMotionListener Contiene los métodos mouseDragged y mouseMoved, utiliza el evento MouseEvent que permite conocer el objeto que ha generado el evento, la posición x, y en la que se ha generado el evento(relativa a la esquina superior izquierda del componente)
Para asociar el componente a una clase de tratamiento de evento de ratón se usa el método addMouseListener.
Para asociar el componente a una clase de tratamiento de evento de movimiento de ratón se usa el método addMouseMotionListener.
Para asociar el componente a una clase de tratamiento de evento de teclado se usa el método addKeyListener.
El interfaz MouseMotionListener, contiene el método mouseDragged.
El interfaz KeyListener contiene 3 métodos, tiene asociado el adaptador KeyAdapter
El interfaz WindowListener contienen el método windowClosed
El objeto KeyEvent contiene el metodo getKeyCode
focusGained es un método del interfaz FocusListener y de la clase FocusAdapter
itemStateChanged es un método del interfaz ItemListener
Los métodos addItemListener y addActionListener existen

--O-J-O-- --O-J-O-- --O-J-O-- --O-J-O-- --O-J-O--

// pendientes npi

/*
Se puede reemplazar por la llamada a un método que sea capas de leer de la consola
System.out.println ("Introduce la matricula: ");
String matricula = Teclado.Lee_String();
*/

// Las que no, sólo son accesibles desde dentro del paquete(sirven para dar soporte a las clases públicas)
// ????

// pendiente de picar y de probar el código

	InstanceOf.java
    public class InstanceOf{
    public static void main (String[]args){
        if( Impuesto instanceof float) {
            System.out.println("Impuesto is a float");
        }
        else if( Impuesto instanceof Integer) {
            System.out.println("Impuesto is an Integer");
        }
        
        if( Impuesto instanceof Comparable) {
            //subclasses of Number like Double etc. implement Comparable
            //other subclasses might not -> you could pass Number instances that don't implement that interface
            System.out.println("Impuesto is comparable"); 
        }
    }
}
// pendiente de picar y de probar el código
	Matriz3Scanner.java
    import java.util.Scanner; //Importación del código de la clase Scanner desde la biblioteca Java
public class Matriz3Scanner{
    //Nombres[], Notas[]
    public static void Imprimir(String [][] Alumnos){
        
        for (int i=0; i < Alumnos[0].length; i++){
            int j=i+1;
            System.out.println(j + ". " + Alumnos[0][i] + ": " + Alumnos[1][i]);
        }
    }
    public static byte EntreNotas(float Nota1, float Nota2, String [][] Alumnos){
        byte Contador = 0;
        for(int i=0; i<Alumnos[0].length; i++){
        
            if( (Float.parseFloat(Alumnos[1][i]) >= Nota1) && 
                (Float.parseFloat(Alumnos[1][i]) <= Nota2) ){
                 Contador++;
                 System.out.println(Alumnos[0][i] + ": " + Alumnos[1][i]); //Nombres[], Notas[]
            }
                
        }
        //Después de la ejecución del método se esta imprimiendo la variable Contador, pero no sé porque???
        return (Contador);
    }
        
    
    public static String Lee_String(Scanner Cadena){
        
        String entradaString = Cadena.nextLine();
        
        return (entradaString);
    }
    
    public static float Lee_Float(Scanner Fnumber){
        
        float entradaFloat = Fnumber.nextFloat();
        
        return(entradaFloat);
    }
    
    
    
    public static void main(String [] args){
        
        final byte NUM_ALUMNOS = 5;
        
        //Solo es obligatorio indicar el número de filas.
        //Matriz de Calificaciones = 2filas X 5columnas cada una;
        String [][] Calificaciones = new String[2][NUM_ALUMNOS];
        
        // Inicializa la Matriz de Calificaciones
        
        for (int i=0; i < NUM_ALUMNOS; i++){
            
            Scanner entradaNombres = new Scanner(System.in);
            System.out.println("Digite el Nombre del Alumno: ");
            Calificaciones[0][i] = Lee_String(entradaNombres);
            
            Scanner entradaNota = new Scanner(System.in);
            System.out.println("Digite la Nota del Alumno (Use , para los decimales): ");
            Calificaciones[1][i] = Float.toString(Lee_Float(entradaNota));
            
        }
        
        Imprimir (Calificaciones);
        System.out.println("\n");
        
        System.out.println("Aprobados: ");
        System.out.println(EntreNotas(5.0f,10.0f,Calificaciones));
        
        System.out.println("Suspensos: ");
        System.out.println(EntreNotas(0.0f,4.9f,Calificaciones));
        
        System.out.println("Matriculas: ");
        System.out.println(EntreNotas(10.0f,10.0f,Calificaciones));
    }
}
//
Revisar Calculadora - Sin los eventos,  contiene las clases Digitos, Operadores, Resultados, GUICalculadora* y Calculadora*
                                        esta sin importar MyFrame1 ..etc y sin modificar el package y sin las clases de Controldeeventos
---------------------------
|  _____________________  |
| |                     | |
| |_____________________| |
---------------------------
| ----- ----- ----- ----- |
| | 7 | | 8 | | 9 | | + | |     -> 2*3+1;   2*3+2;    2*3+3;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 4 | | 5 | | 6 | | - | |     -> 1*3+1;   1*3+2;    1*3+3;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 1 | | 2 | | 3 | | * | |     -> 0*3+1;   0*3+2;    0*3+3;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 0 | | . | | = | | / | |     ->     0;       .;        =;
| ----- ----- ----- ----- |
---------------------------

GUI mejorada
----------------------------------
|  ____________________________  |
| |                            | |
| |____________________________| |
----------------------------------
| ----- ----- ----- -----  ----- |
| | 7 | | 8 | | 9 | | % |  | / | |
| ----- ----- ----- -----  ----- |
| ----- ----- ----- ----- ------ |
| | 4 | | 5 | | 6 | | * | |sqrt| |
| ----- ----- ----- ----- ------ |
| ----- ----- ----- -----  ----- |
| | 1 | | 2 | | 3 | |   |  | - | |
| ----- ----- ----- | + |  ----- |
| ----- ----- ----- |   |  ----- |
| | C | | 0 | | . | |   |  | = | |
| ----- ----- ----- -----  ----- |
----------------------------------